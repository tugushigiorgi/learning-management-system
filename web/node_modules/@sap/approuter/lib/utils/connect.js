'use strict';
if (process.env.CONNECT === 'original') {
  return module.exports = require('connect');
}
const EventEmitter = require('events');
const http = require('http');
const isPathMatch = (expected, actual) => expected === '' || (actual.startsWith(expected) && [undefined, '.', '/'].includes(actual[expected.length]));
const escapeMap = {'"': '&quot;', '&': '&amp;', '\'': '&#39;', '<': '&lt;', '>': '&gt;', '\n': '<br>', '`': '&#x60;'};
const escapeHtml = msg => msg.split('').map(ch => (escapeMap[ch] || ch)).join('').replace(/\x20{2}/g, ' &nbsp;');
const isNotProduction = (process.env.NODE_ENV !== 'production');
module.exports = () => {
  const okQueue = [], errQueue = [];
  const handle = (req, res, out) => {
    out = out || (err => {
      if (res.headersSent) { return; }
      if (!err) { res.statusCode = 404; return res.end('<html><body><pre>Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(encodeURI(req.url)) + '</pre></body></html>'); }
      if (res.statusCode === 200) { res.statusCode = (err.status || err.statusCode || 500); }
      if (err.headers) { for (let [key, val] of Object.entries(err.headers)) { res.setHeader(key, val); } }
      if (req.method !== 'HEAD') {
        res.write(escapeHtml((isNotProduction && err.stack) || (err.toString && err.toString()) || http.STATUS_CODES[res.statusCode]));
      }
      res.end();
    });
    req.originalUrl = req.url;
    const next = (err) => {
      if (err && !lastError) { lastError = err; i = queue[i - 1][1]; queue = errQueue; args.unshift(lastError); }
      if (i < queue.length) {
        if (!isPathMatch(queue[i][0].route, reqPathLowerCase)) { i++; return next(); }
        try {
          reqUrl = reqOrigin + ((u => u[0] === '/' ? u : '/' + u)(reqPath.slice(queue[i][0].route.length)));
          return queue[i++][0].handle.apply(null, args);
        } catch (err) {
          return next(err);
        }
      }
      out(err);
    };
    let args = [req, res, next], queue = okQueue, lastError = null, i = 0, reqUrl = req.url, reqOrigin = '', reqPath, reqPathLowerCase;
    Object.defineProperty(req, 'url', {
      get: () => reqUrl,
      set: (newUrl) => {
        reqUrl = newUrl;
        reqPath = newUrl;
        const isFQDN = (newUrl[0] !== '/');
        if (isFQDN) {
          let pathStart = 0;
          const afterSchemaIdx = reqUrl.indexOf('://') + 3, queryStart = reqUrl.indexOf('?', afterSchemaIdx), slashStart = reqUrl.indexOf('/', afterSchemaIdx);
          pathStart = queryStart < 0 ? slashStart : Math.min(queryStart, slashStart);
          reqOrigin = newUrl.slice(0, pathStart);
          reqPath = newUrl.slice(pathStart);
        }
        reqPathLowerCase = reqPath.toLowerCase().split('?')[0];
      }
    });
    req.url = reqUrl;
    next();
    return handle;
  };
  Object.assign(handle, EventEmitter.prototype);
  handle.route = '/';
  handle.handle = handle;
  handle.stack = [];
  handle.use = (path, fn) => {
    if (typeof path !== 'string') { fn = path; path = ''; }
    if (path.at(-1) === '/') { path = path.slice(0, -1); }
    if (fn instanceof http.Server) { fn = fn.listeners('request')[0]; }
    if (fn.handle) { fn.route = path; }
    handle.stack.push({ route: path.toLowerCase(), handle: fn });
    (fn.length < 4 ? okQueue : errQueue).push([handle.stack.at(-1), errQueue.length]);
    return handle;
  };
  handle.listen = (...args) => http.createServer(handle).listen(...args);
  handle.stack.splice = function splice(start, deleteCount, ...items) {
    const r = Array.prototype.splice.call(handle.stack, start, deleteCount, ...items);
    okQueue.length = 0; errQueue.length = 0;
    for (let el = handle.stack[0], i = 0; i < handle.stack.length; el = handle.stack[i++]) {
      (el.handle.length < 4 ? okQueue : errQueue).push([el, errQueue.length]);
    }
    return r;
  };
  return handle;
};