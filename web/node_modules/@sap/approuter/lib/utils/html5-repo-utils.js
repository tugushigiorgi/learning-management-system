'use strict';
const request             = require('./request-utils');
const tokenUtils          = require('./token-utils');
const headerUtils         = require('./header-util');
const html5RepoService    = 'html5-apps-repo-rt';
const url                 = require('url');
const stdTTL              = process.env.HTML5_APPS_CACHE || 300;
const checkPeriod         = stdTTL + 20;
const NodeCache           = require('node-cache');
const html5AppsCache      = new NodeCache({stdTTL: stdTTL, checkperiod: checkPeriod});
const enrichedHTML5AppsCache      = new NodeCache({stdTTL: stdTTL, checkperiod: checkPeriod});
const logUtil             = require('./application-logs-utils');
const { promisify }         = require('util');
const vcapUtils = require('./vcap-utils');
const passportUtils = require('../passport/utils');
const CONFIG_CREDENTIALS  = 'com.sap.service-credentials';
const html5RTService = 'html5-apps-repo-rt';
const emptyResponse = {};

const HttpsAgentKeepAlive = require('agentkeepalive').HttpsAgent;
const agentTimeOut = (process.env.HTML5_REPO_KEEP_ALIVE_TIMEOUT && Number(process.env.HTML5_REPO_KEEP_ALIVE_TIMEOUT)) || 60000;
const html5RepoKeepAliveDisabled = process.env.DISABLE_HTML5_REPO_KEEP_ALIVE && process.env.DISABLE_HTML5_REPO_KEEP_ALIVE.toLowerCase() === 'true';
const httpsKeepAliveAgent = new HttpsAgentKeepAlive(
  {
    timeout: agentTimeOut,
    freeSocketTimeout: agentTimeOut / 2,
  }
);


module.exports.cacheHTML5Applications            = cacheHTML5Applications;
module.exports.getHTML5Applications              = getHTML5Applications;
module.exports.downloadHTML5Application          = downloadHTML5Application;
module.exports.getCredentials                    = getCredentials;
module.exports.getDestinations                   = getDestinations;
module.exports.attachCredentials                 = attachCredentials;
module.exports.getHTML5RepoToken                 = getHTML5RepoToken;
module.exports.enrichWithHTML5RepoData           = enrichWithHTML5RepoData;
module.exports.getApplicationsMetadata           = getApplicationsMetadata;
module.exports.getSubscribedApplicationsMetadata = getSubscribedApplicationsMetadata;
module.exports.html5AppsCache                    = html5AppsCache;

const technicalCacheBusterApplication = 'technical';
module.exports.technicalCacheBusterApplication = technicalCacheBusterApplication;

async function cacheHTML5Applications(req,appKey) {
  const cacheKey = getCacheKey(req, appKey);
  let sapCloudServiceKeys = html5AppsCache.get(cacheKey);
  // Fill the html5 apps cache if cache is empty or explicitly requested to fetch from html5 repo
  if (req.skipCachedApps || !sapCloudServiceKeys) {
    const queries = getQueryParams(req, appKey);
    const appHostId = appKey && appKey.appDestinationId;
    let applicationsMetadata = await exports.getApplicationsMetadata(req, queries, appHostId);
    if (applicationsMetadata && applicationsMetadata.length > 0) {
      _addHTML5ApplicationsToCache(applicationsMetadata, req, cacheKey);
    }

    const addApps = req.apiName === '/applications';
    if ((!applicationsMetadata || applicationsMetadata.length === 0) || addApps) {
      applicationsMetadata = await exports.getSubscribedApplicationsMetadata(req, queries);
      if (applicationsMetadata && applicationsMetadata.length > 0) {
        _addHTML5ApplicationsToCache(applicationsMetadata, req, cacheKey, addApps);
      } else if (!addApps) {
        html5AppsCache.set(cacheKey, emptyResponse);
      }
    }
  }
}

async function getHTML5Applications(req) {
  let sapCloudServiceKeys = !req.skipCachedApps && html5AppsCache.get(req.tenant);
  if (!sapCloudServiceKeys){
    await cacheHTML5Applications(req);
    sapCloudServiceKeys = html5AppsCache.get(req.tenant);
  }
  const approuterHost = req.HTML5AppHost.indexOf('https://') !== 0 ? 'https://' + req.HTML5AppHost : req.HTML5AppHost;
  let result = {
    applications: [],
    errors: []
  };
  if (sapCloudServiceKeys) {
    const appKeys = {};
    for (let sapCloudServiceKey in sapCloudServiceKeys) {
      sapCloudServiceKeys[sapCloudServiceKey].applications.forEach((app) => {
        const serviceKeyComponents = _getSapCloudServiceKeyComponents(sapCloudServiceKey,true);
        const baseAppKey = serviceKeyComponents.serviceName + '.' + app.applicationName + '-' + app.applicationVersion;
        const uniqueAppKey = app.appHostId + '.' + serviceKeyComponents.serviceName + '.' + app.applicationName + '-' + app.applicationVersion;
        app['url'] = approuterHost + '/' + baseAppKey;
        app['uniqueUrl'] = approuterHost + '/' + app.appHostId + '.' + baseAppKey;
        app['destinations'] = sapCloudServiceKeys[sapCloudServiceKey].destinations;
        app['businessServices'] = _getBoundBusinessServices(sapCloudServiceKeys[sapCloudServiceKey].credentials);
        if (!appKeys[uniqueAppKey]) {
          appKeys[uniqueAppKey] = uniqueAppKey;
          result.applications.push(app);
        }
      });
    }
  }
  return result;
}
async function enrichWithHTML5RepoData(cachedApps,queryParams,req) {
  const cacheKey = queryParams ? `${req.tenant}_?${queryParams}` : `${req.tenant}`;
  !queryParams && (queryParams = '');
  let cachedResult = enrichedHTML5AppsCache.get(cacheKey);
  if (cachedResult) {
    return cachedResult;
  }
  const runtimeHost = req.HTML5AppHost.indexOf('https://') !== 0 ? 'https://' + req.HTML5AppHost + '/' : req.HTML5AppHost + '/';
  const result = {
    applications: [],
    errors: []
  };

  // Get local apps
  const appsMetadata = await exports.getApplicationsMetadata(req, queryParams, null);
  appsMetadata.forEach(app => {
    _addAppToResult(app, result, cachedApps, runtimeHost);
  });

  // Try to get business services apps pointed by destinations, and subscribed apps
  const fetchApplicationsPromises = [];
  for (let appHostId in cachedApps) {
    if (!cachedApps[appHostId].appFound) {
      fetchApplicationsPromises.push(new Promise((resolve) => {
        resolve(exports.getApplicationsMetadata(req, queryParams, appHostId));
      }));
    }
  }
  const html5RepoResult = await Promise.all(fetchApplicationsPromises);
  const bsappsMetadata = html5RepoResult.flat();
  bsappsMetadata.forEach(app => {
    _addAppToResult(app, result, cachedApps, runtimeHost);
  });

  // Check for missing apps
  for (let appHostId in cachedApps) {
    const cachedAppElement = cachedApps[appHostId];
    if (!cachedAppElement.appFound) {
      const destinationIdentifier = cachedAppElement.destId || cachedAppElement.destName;
      if (destinationIdentifier) {
        result.errors.push(
          {
            destinationId: cachedAppElement.destId,
            destinationName: cachedAppElement.destName,
            sapCloudService: cachedAppElement.sapCloudService,
            appHostId: appHostId,
            reason: 'Invalid App Host ID'
          });
      } else {
        result.errors.push(
          {
            appHostId: appHostId,
            reason: 'No html5 applications found in App Host'
          });
      }
    }
  }
  enrichedHTML5AppsCache.set(cacheKey, result);
  return result;
}

function _addAppToResult(app, result, cachedApps, runtimeHost) {
  const cachedAppElement = cachedApps[app.appHostId];
  // Managed Approuter needs a runtime url with sap.cloud.service, it may come from manifest.json or destination
  if (cachedAppElement && (app.sapCloudService || (cachedAppElement.destIds && cachedAppElement.destIds.length > 0) || cachedAppElement.destName)) {
    const credentials = app.configuration && app.configuration[CONFIG_CREDENTIALS];
    const html5RuntimeEnabled = app.configuration && app.configuration['HTML5Runtime_enabled'];
    const embeddedCredsApp = !!((credentials && (credentials.xsuaa || credentials.identity)) || html5RuntimeEnabled);
    app.destinationName = cachedAppElement.destinationName;
    app.subscribedAppName = cachedAppElement.subscribedAppName;
    app.subscribedCommercialAppName = cachedAppElement.subscribedCommercialAppName;
    app.identityZone = app.subdomain;
    app['app-host-id'] = app.appHostId;
    const sapCloudService = cachedAppElement.sapCloudService || app.sapCloudService;
    app['sap.cloud.service'] = sapCloudService;
    const sapCloudServiceNoDots = sapCloudService && sapCloudService.replace(/\./g, '');
    app.destinations = app.configuration && app.configuration.destinations;
    app.businessServices = credentials && _getBoundBusinessServices(credentials);
    delete app.configuration;
    embeddedCredsApp && (app.configuration = true);
    cachedApps[app.appHostId].appFound = true;
    if (cachedAppElement.destIds && cachedAppElement.destIds.length > 0) {
      cachedAppElement.destIds.forEach(destId => {
        const newApp = Object.assign({}, app);
        newApp.destinationId = destId;
        const destIdSection = newApp.destinationId + '.';
        newApp.url = `${runtimeHost}${destIdSection}${sapCloudServiceNoDots}.${newApp.applicationName}-${newApp.applicationVersion}`;
        result.applications.push(newApp);
      });
    } else {
      app.url = `${runtimeHost}${sapCloudServiceNoDots}.${app.applicationName}-${app.applicationVersion}`;
      app.uniqueUrl = embeddedCredsApp && `${runtimeHost}${app.appHostId}.${sapCloudServiceNoDots}.${app.applicationName}-${app.applicationVersion}`;
      result.applications.push(app);
    }
  }
}

async function downloadHTML5Application(req, res){
  const dynamicRoutingUtils = require('./dynamic-routing-utils');
  const appKey = dynamicRoutingUtils.getApplicationKey({url: '/' + url.parse(req.url).path.split('/')[3]});
  const html5Applications = await getHTML5Applications(req);
  let appHostId;

  for (let i = 0; i < html5Applications.applications.length; i++) {
    if (html5Applications.applications[i]['sapCloudService'].replace(/\./g, '') === appKey.appPrefix &&
        html5Applications.applications[i].applicationName === appKey.appNameWithoutPrefix &&
        html5Applications.applications[i].applicationVersion === appKey.appVersion &&
        ((appKey.appDestinationId && appKey.appDestinationId === html5Applications.applications[i]['appHostId']) ||
            !appKey.appDestinationId)) {
      appHostId = html5Applications.applications[i]['appHostId'];
      break;
    }
  }
  if (!appHostId) {
    res.statusCode = 404;
    return res.end();
  }
  const path = '/applications/content/' + appKey.appNameWithoutPrefix + '-' + appKey.appVersion;
  const requestOptions = await _getHTML5RepoOptions(req, path, appHostId);
  await request.pipe(requestOptions,res);
}

function getCredentials(serviceName, req){
  const configuration = getConfiguration(serviceName, req);
  return configuration && (configuration.credentials || configuration);
}

function attachCredentials(appKey, dependentServiceName,contextId, req){
  const mainServiceName = appKey && appKey.appPrefix;
  if (!req.html5RepoCredentials && mainServiceName) {
    const cacheKey = getCacheKey(req, appKey);
    const sapCloudServiceKeys = req && req.tenant && html5AppsCache.get(cacheKey);
    if (!sapCloudServiceKeys) {
      return null;
    }
    req.html5RepoCredentials = {};
    let serviceFound = false;
    for (let sapCloudServiceKey in sapCloudServiceKeys) {
      const serviceKeyComponents = _getSapCloudServiceKeyComponents(sapCloudServiceKey, true);
      const apps = sapCloudServiceKeys[sapCloudServiceKey].applications;
      if ((contextId && contextId === serviceKeyComponents.appHostId && serviceKeyComponents.serviceName === mainServiceName) ||
          (contextId && apps.find(app => app.applicationId === contextId || app.applicationName === contextId) && serviceKeyComponents.serviceName === mainServiceName) ||
          (!contextId && serviceKeyComponents.serviceName === mainServiceName)) {
        serviceFound = true;
        req.html5RepoCredentials[mainServiceName] = sapCloudServiceKeys[sapCloudServiceKey].credentials;
        req.html5RepoDestinations = sapCloudServiceKeys[sapCloudServiceKey].destinations;

        const destinations = getDestinations(req);
        if (destinations) {
          req.html5Destinations = destinations;
        }

        if (!dependentServiceName){
          return;
        }
        for (let prop in sapCloudServiceKeys[sapCloudServiceKey].credentials) {
          const bsCredentials = sapCloudServiceKeys[sapCloudServiceKey].credentials[prop];
          const bsName = bsCredentials && bsCredentials['sap.cloud.service'] && bsCredentials['sap.cloud.service'].replace(/\./g, '');
          // eslint-disable-next-line max-depth
          if (bsName === dependentServiceName) {
            bsCredentials.uniqueServiceName = bsCredentials.uaa && bsName + '!' + bsCredentials.uaa.serviceInstanceId;
            req.html5RepoCredentials[dependentServiceName] = bsCredentials;
          }
        }
      }
    }
    if (!serviceFound){
      req.html5RepoCredentials = null;
    }
  }
}

function getDestinations(req){
  const destinations = req && req.html5RepoDestinations;
  const validators  = require('../configuration/validators');
  destinations && validators.validateDestinations(destinations);
  return destinations && destinations.reduce((obj, item) => Object.assign(obj, { [item.name]: item}), {});
}

function getConfiguration(serviceName, req) {
  if (!req || !req.html5RepoCredentials) {
    return null;
  }

  const normalizedServiceName = serviceName.replace(/\./g, '');
  let configuration = req.html5RepoCredentials[normalizedServiceName] || null;

  if (!configuration) {
    for (const key in req.html5RepoCredentials) {
      const value = req.html5RepoCredentials[key];
      if (typeof value === 'object') {
        configuration = Object.values(value).find(
          (entry) => entry && entry['sap.cloud.service'] === serviceName
        );

        if (configuration && configuration['sap.cloud.service']) {
          const serviceId = configuration.uaa && configuration.uaa.serviceInstanceId;
          configuration.uniqueServiceName = serviceId
            ? configuration['sap.cloud.service'] + '!' + serviceId
            : configuration['sap.cloud.service'];
          break;
        }
      }
    }
  }
  return configuration || null;
}

async function getHTML5RepoToken(req) {
  let html5RepoToken = req.app.services && req.app.services[html5RTService] &&
      req.app.services[html5RTService].token && req.app.services[html5RTService].token.accessToken;
  if (!html5RepoToken) {
    let html5Cred = vcapUtils.getServiceCredentials({tag: html5RTService});
    const loadClientCredentialsTokenProm = promisify(tokenUtils.loadClientCredentialsToken);
    await loadClientCredentialsTokenProm(req.app, headerUtils.getCorrelationId(req), html5Cred, html5RTService);
    html5RepoToken = req.app.services && req.app.services[html5RTService] &&
        req.app.services[html5RTService].token && req.app.services[html5RTService].token.accessToken;
  }
  return html5RepoToken;
}

function _addHTML5ApplicationsToCache(applicationsMetadata, req, cacheKey, addApps) {
  let html5ApplicationsCache = addApps ? html5AppsCache.get(cacheKey) : {};
  html5ApplicationsCache = html5ApplicationsCache || {};
  applicationsMetadata.forEach((app) => {
    const configuration       = app.configuration && Object.assign({}, app.configuration);
    const credentials         = configuration && configuration[CONFIG_CREDENTIALS];
    const destinations        = configuration && configuration['destinations'];
    const html5RuntimeEnabled = configuration && configuration['HTML5Runtime_enabled'] || app.applicationType === technicalCacheBusterApplication;
    const iasDependencyName   = configuration && configuration['IASDependencyName'];
    const skipApp    = app.applicationType === technicalCacheBusterApplication && req.apiName;
    app.configuration   = !!configuration;
    if (app.configuration && ((credentials && (credentials.xsuaa || credentials.identity)) || html5RuntimeEnabled)
        && app.sapCloudService && !skipApp) {
      let sapCloudServiceKey = app.sapCloudService + '!' + app.appHostId;
      if (!html5ApplicationsCache[sapCloudServiceKey]) {
        html5ApplicationsCache[sapCloudServiceKey] = {
          credentials: {serviceName: app.sapCloudService, uniqueServiceName: sapCloudServiceKey},
          destinations: destinations,
          applications: []
        };
        html5ApplicationsCache[sapCloudServiceKey].applications.push(app);

        for (const prop in configuration[CONFIG_CREDENTIALS]) {
          if (prop === 'xsuaa') {
            html5ApplicationsCache[sapCloudServiceKey].credentials['uaa'] = credentials[prop][0]['credentials'];
          } else if (prop === 'identity') {
            html5ApplicationsCache[sapCloudServiceKey].credentials['ias'] = credentials[prop][0]['credentials'];
          } else if (credentials[prop][0]['credentials'] && credentials[prop][0]['credentials']['sap.cloud.service'] === 'html5-apps-repo-dt') {
            html5ApplicationsCache[sapCloudServiceKey].credentials['html5-apps-repo'] = credentials[prop][0]['credentials'];
          } else {
            html5ApplicationsCache[sapCloudServiceKey].credentials[prop] = credentials[prop][0]['credentials'];
          }
        }

        if (iasDependencyName) {
          html5ApplicationsCache[sapCloudServiceKey].credentials['ias'] = { 'IASDependencyName': iasDependencyName};
        }

        if (!html5ApplicationsCache[sapCloudServiceKey].credentials['uaa'] && !html5ApplicationsCache[sapCloudServiceKey].credentials['ias']){
          html5ApplicationsCache[sapCloudServiceKey].credentials['ias'] = { 'sharedIASToken': true};
        }

      } else {
        html5ApplicationsCache[sapCloudServiceKey].applications.push(app);
      }
    }
  });
  html5AppsCache.set(cacheKey, html5ApplicationsCache);
}

async function _getHTML5RepoOptions(req, path, appHostId) {
  const bsUtils = require('./business-service-utils');
  const html5RepoCredentials = bsUtils.getCredentials(html5RepoService);
  if (!html5RepoCredentials) {
    throw new Error('Missing html5 apps repo binding');
  }
  const requestOptions = {
    url: html5RepoCredentials && (html5RepoCredentials.uri + path),
    headers: {}
  };
  if (appHostId){
    requestOptions.headers['x-app-host-id'] = appHostId;
  }

  const logInfo = passportUtils.getTenantInfo(req).logInfo;
  logInfo && (requestOptions.headers['tenantid'] = logInfo);

  if (req.app.services && req.app.services[html5RepoService] && req.app.services[html5RepoService][req.tenant]
      && req.app.services[html5RepoService][req.tenant].token
      && req.app.services[html5RepoService][req.tenant].token.tokenRefreshTimestamp - Date.now() > 0) {
    requestOptions.headers.Authorization = 'Bearer ' + req.app.services[html5RepoService][req.tenant].token.accessToken;
  } else {
    let tokenCredentials = html5RepoCredentials.uaa;
    tokenCredentials.label = html5RepoCredentials['sap.cloud.service'];
    const token = await tokenUtils.getClientCredentialsToken(req.tenant, headerUtils.getCorrelationId(req), tokenCredentials, null);
    if (!req.app.services[html5RepoService]) {
      req.app.services[html5RepoService] = {};
    }
    req.app.services[html5RepoService][req.tenant] = {token: token};
    requestOptions.headers.Authorization = 'Bearer ' + req.app.services[html5RepoService][req.tenant].token.accessToken;
  }
  requestOptions.cache = {services: req.app.services, serviceName: html5RepoService};
  if (!html5RepoKeepAliveDisabled) {
    logUtil.logRequestInfo(req,`Adding keep-alive agent to HTML5 applications metadata query from tenant ${req.tenant}`);
    requestOptions.httpsAgent = httpsKeepAliveAgent;
  }
  return requestOptions;
}

function _getSapCloudServiceKeyComponents(sapCloudServiceKey, ignoreDots){
  const indexOfAppHostId = sapCloudServiceKey.indexOf('!');
  const appHostId = sapCloudServiceKey.substring(indexOfAppHostId + 1);
  let html5AppServiceName = indexOfAppHostId > -1 ? sapCloudServiceKey.substring(0, indexOfAppHostId) : sapCloudServiceKey;
  html5AppServiceName = ignoreDots ? html5AppServiceName.replace(/\./g, '') : html5AppServiceName;
  return {
    serviceName : html5AppServiceName,
    appHostId   : appHostId
  };
}

function _getBoundBusinessServices(credentials){
  const boundServices = [];
  for (let serviceName in credentials){
    if (serviceName !== 'destination' && serviceName !== 'html5-apps-repo'
        && serviceName !== 'uaa' && serviceName !== 'ias' && serviceName !== 'serviceName' && serviceName !== 'uniqueServiceName'){
      boundServices.push({
        instanceName   : serviceName,
        html5AppRepo   : credentials[serviceName]['html5-apps-repo'],
        sapCloudService: credentials[serviceName]['sap.cloud.service']
      });
    }
  }
  return boundServices;
}

async function getApplicationsMetadata(req, queries, appHostId) {
  const requestOptions = await _getHTML5RepoOptions(req, `/applications/metadata/${queries}`, appHostId);
  logUtil.logRequestInfo(req,`Fetching HTML5 applications metadata for query ${queries} from tenant ${req.tenant}`);
  const result = await request.axiosRequest('get',requestOptions);
  const responseStatus = (result.response && result.response.statusCode) || 'unknown';
  if (result.error || (responseStatus !== 200 && responseStatus !== 404)){
    const responseData = result && result.response && result.response.response && result.response.response.data;
    if (responseStatus === 400 && responseData === 'Invalid App Host ID'){ // Must be a destination Id --> use destinations flow
      return [];
    }
    const message = result.error || (result.response && result.response.message) || 'No applications metadata response body';
    throw new Error(`Failed to fetch applications metadata from html5 apps repo ${message}, html5 apps repo response status: ${responseStatus}`);
  }
  const applicationsMetadata = result.body && JSON.parse(result.body);
  const appsFound = applicationsMetadata && applicationsMetadata.length > 0 ? applicationsMetadata.length : 0;
  logUtil.logRequestInfo(req,`${appsFound} HTML5 applications retrieved for query ${queries} from tenant ${req.tenant}`);
  return applicationsMetadata;
}

async function getSubscribedApplicationsMetadata(req, queries) {
  const requestOptions = await _getHTML5RepoOptions(req, '/applications/subscriptions');
  logUtil.logRequestInfo(req,`Fetching subscribed HTML5 applications metadata for query ${queries} from tenant ${req.tenant}`);
  const result = await request.axiosRequest('get',requestOptions);
  if (result.error){
    throw new Error('Failed to fetch applications metadata ' + result.error
        + (result.response && result.response.statusCode ? `response status ${result.response.statusCode}` : ''));
  }
  const subscribedApplications = result.body && JSON.parse(result.body);
  const appsFound = subscribedApplications && subscribedApplications.length > 0 ? subscribedApplications.length : 0;
  logUtil.logRequestInfo(req,`${appsFound} subscribed HTML5 applications retrieved for query ${queries} from tenant ${req.tenant}`);
  return subscribedApplications;
}

function getCacheKey(req, appKey){
  let cacheKey = req.tenant;
  appKey && (cacheKey += `_${appKey.appPrefix}`);
  appKey && appKey.appNameWithoutPrefix && (cacheKey += `_${appKey.appNameWithoutPrefix}`);
  appKey && appKey.appVersion && (cacheKey += `_${appKey.appVersion}`);
  return cacheKey;
}

function getQueryParams(req, appKey){
  let queries = '';
  if (!req.apiName && appKey) { // runtime request
    queries = `?sapCloudService=${appKey.appPrefix}&applicationName=${appKey.appNameWithoutPrefix}`;
    appKey.appVersion && (queries += `&applicationVersion=${appKey.appVersion}`);
    queries += '&returnTechnicalApp=true';
  } else if (req.apiName === '/applications') {
    const queryIndex = req.url.indexOf('?');
    queries = queryIndex > -1 ? req.url.slice(queryIndex) : '';
  }
  return queries;
}