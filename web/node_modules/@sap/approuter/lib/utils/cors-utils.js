'use strict';

module.exports = {
  matchTheHostAndUriPattern: matchTheHostAndUriPattern,
  matchTheHostPattern: matchTheHostPattern
};

function matchTheHostAndUriPattern (req, corsConfig) {
  let hostPatternMatch = true;
  if (corsConfig) {
    if (corsConfig.hostPattern) {
      hostPatternMatch = matchTheHostPattern(req, corsConfig);
    }
  }
  const uriPatternMatch = corsConfig.uriPattern.test(req.url);

  return hostPatternMatch && uriPatternMatch;
}

function matchTheHostPattern (req, corsConfig) {
  if (req && corsConfig && corsConfig.hostPattern) {
    const hostObj = getHostObject(req);
    let hostNameMatch = false;
    let hostNameAndPortMatch = false;

    if (hostObj.name) {
      hostNameMatch = corsConfig.hostPattern.test(hostObj.name);
      // match the hostname + port
      if (hostObj.port) {
        const hostStr = hostObj.name.concat(':').concat(hostObj.port);
        hostNameAndPortMatch = corsConfig.hostPattern.test(hostStr);
      }
    }

    return hostNameMatch || hostNameAndPortMatch;
  }

  return true;
}

function getHostObject (req) {
  const reqHeadersHost = evaluateHost(req);
  const hostObj = {};
  if (reqHeadersHost) {
    const hostHeaderParts = reqHeadersHost.split(':');
    if (hostHeaderParts.length === 2) {
      // check if the second header part (port) is integer
      if (Number.parseInt(hostHeaderParts[1]) >= 0) {
        hostObj.name = hostHeaderParts[0];
        hostObj.port = hostHeaderParts[1];
      }
      else {
        hostObj.name = reqHeadersHost;
      }
    }
    else {
      hostObj.name = reqHeadersHost;
    }
  }

  return hostObj;
}

/**
 * Custom method to evaluate the request host. The external host (sent by the client) is returned and the internal one (x-custom-host) is ignored in case of external reverse proxy.
 *
 * @param {*} req the request object contains the headers
 * @returns the request headers host
 */
function evaluateHost(req) {
  return req.headers['x-forwarded-host'] ||  req.headers.host || req.headers[':authority'];
}
