/* eslint-disable camelcase */
'use strict';

const xsenv = require('@sap/xsenv');
const validators = require('../configuration/validators');
const passportUtils = require('../passport/utils');
const loggerUtils = require('./logger');
const headerUtils = require('./header-util');
const tracer = loggerUtils.getTracer(__filename);
const request = require('./request-utils');
const { XsuaaService, IdentityService } = require('@sap/xssec');
const jwtDecode = require('jwt-decode');
const {URL} = require('url');
const tokenCache = {};
const timeout = 5000;

exports.getTokens = getBSTokens;
exports.loadClientCredentialsToken = loadClientCredentialsToken;
exports.getClientCredentialsTokenByTenant = getClientCredentialsTokenByTenant;
exports.getClientCredentialsToken = getClientCredentialsToken;
exports.exchangeToken = exchangeToken;
exports.getRefreshToken = getRefreshToken;
exports.getTokenInfo = getTokenInfo;
exports.getPasswordUserToken = getPasswordUserToken;
exports.deleteTokenCache = deleteTokenCache;
exports.getApp2AppToken = getApp2AppToken;
exports.checkSecurityContext = checkSecurityContext;
exports.createAuthService = createAuthService;
exports.getIASClientCredentialsToken = getIASClientCredentialsToken;

function createAuthService(credentials, type) {
  const creds = Object.assign({}, credentials.url ? credentials : credentials.uaa || credentials);
  if (creds.url && creds.tokenURL) {
    const parsedCredsUrl = new URL(creds.url);
    const parsedTokenUrl = new URL(creds.tokenURL);
    parsedCredsUrl.host = parsedTokenUrl.host;
    creds.url = parsedCredsUrl.toString();
  }
  creds.apptid && (creds.app_tid = creds.apptid);
  const isIdentityService = type ? type.toLowerCase() === 'ias' : creds.authenticationType === 'ias' || creds.domain || creds.app_tid;
  return isIdentityService ? new IdentityService(creds) : new XsuaaService(creds);
}

function getBSTokens(app) {
  if (process.env.SKIP_CLIENT_CREDENTIALS_TOKENS_LOAD) {
    if (!app.services) {
      app.services = {};
    }
    return;
  }
  const DESTINATION = 'destination';
  const CONNECTIVITY = 'connectivity';
  const CLIENT_CREDENTIALS = 'client_credentials';

  const services = xsenv.readServices();
  if (services) {
    for (const serviceName in services) {
      const service = services[serviceName];
      if (service.credentials && (service.label === DESTINATION || service.label === CONNECTIVITY || service.credentials['grant_type'] === CLIENT_CREDENTIALS)) {
        validators.validateClientCredentials(service.credentials);
        loadClientCredentialsToken(app, headerUtils.getCorrelationId(), service.credentials, service.credentials['sap.cloud.service'] || service.label);
      }
    }
  }
}

function getTokenInfo(token) {
  const mask = '********';
  try {
    const tokenDecoded = jwtDecode(token);
    // Mask personal information
    tokenDecoded.given_name && (tokenDecoded.given_name = mask);
    tokenDecoded.family_name && (tokenDecoded.family_name = mask);
    tokenDecoded.email && (tokenDecoded.email = mask);
    tokenDecoded.user_uuid && (tokenDecoded.user_uuid = mask);
    tokenDecoded.sub && (tokenDecoded.sub = mask);
    tokenDecoded.name && (tokenDecoded.name = mask);
    tokenDecoded.userName && (tokenDecoded.userName = mask);
    return tokenDecoded;
  } catch (err) {
    return {
      invalidToken: err
    };
  }
}

async function getClientCredentialsTokenByTenant(correlationId, tenant, credentials, zoneInfo, cb) {
  const authService = createAuthService(credentials);
  const zid = zoneInfo && zoneInfo.apptid;
  try {
    const tokenResponse = await authService.fetchClientCredentialsToken({ correlationId, tenant, zid, timeout });
    const tokenResponseOptions = handleClientCredentialsTokenResponse(
      createTokenResponseOptions(null, tokenResponse, credentials.label, tenant, correlationId)
    );
    if (tokenResponseOptions.errorMessage) {
      const error = new Error(tokenResponseOptions.errorMessage);
      if (cb) {
        return cb(error);
      } else {
        throw error;
      }
    } else {
      if (cb) {
        return cb(null, tokenResponseOptions);
      } else {
        return tokenResponseOptions;
      }
    }
  } catch (err) {
    const tokenResponseOptions = handleClientCredentialsTokenResponse(
      createTokenResponseOptions(err, null, credentials.label, tenant, correlationId)
    );
    tracer.error(`Error getting client_credentials token for ${credentials.label} from subaccount ${tenant}: ${err.message}`);
    const exceptionErr = new Error(tokenResponseOptions.errorMessage || err.message);
    if (cb) {
      return cb(exceptionErr);
    } else {
      throw exceptionErr;
    }
  }
}

async function loadClientCredentialsToken(app, correlationId, credentials, serviceName, cb) {
  const authService = createAuthService(credentials);
  try {
    const tokenResponse = await authService.fetchClientCredentialsToken({ correlationId, timeout });
    const tokenResponseOptions = handleClientCredentialsTokenResponse(
      createTokenResponseOptions(null, tokenResponse, serviceName, credentials.identityzone, correlationId)
    );
    if (tokenResponseOptions.errorMessage) {
      tracer.error(tokenResponseOptions.errorMessage);
      return cb && cb(tokenResponseOptions.errorMessage);
    }
    if (!app.services) {
      app.services = {};
    }
    app.services[serviceName] = { token: tokenResponseOptions };
    const FIVE_MINUTES = 5 * 60 * 1000;
    const tokenRefreshTimestamp = passportUtils.getExpiresAt(tokenResponse.expires_in).getTime() - FIVE_MINUTES;
    const msBeforeRetrieval = Math.max(0, tokenRefreshTimestamp - Date.now()); // Prevent negative timeout
    setTimeout(() => loadClientCredentialsToken(app, correlationId, credentials, serviceName), msBeforeRetrieval);
    return cb && cb();
  } catch (err) {
    const tokenResponseOptions = handleClientCredentialsTokenResponse(
      createTokenResponseOptions(err, null, serviceName, credentials.identityzone, correlationId)
    );

    tracer.error(tokenResponseOptions.errorMessage || err.message);
    return cb && cb(err || tokenResponseOptions.errorMessage);
  }
}

async function getApp2AppToken(idToken, credentials, IASDependencyName, correlationId) {
  const authService = createAuthService(credentials);
  try {
    return await authService.fetchJwtBearerToken(idToken, { correlationId, timeout , resource: `urn:sap:identity:application:provider:name:${IASDependencyName}` });
  } catch (err) {
    throw new Error(`Failed to exchange IAS token: ${err.responseText || err.message}, IASDependencyName=${IASDependencyName}`);
  }
}

async function getIASClientCredentialsToken(credentials, serviceInstanceId, correlationId) {
  const authService = createAuthService(credentials, 'ias');
  try {
    return await authService.fetchClientCredentialsToken({ correlationId, timeout , resource: `urn:sap:identity:application:service:id:${serviceInstanceId}` });
  } catch (err) {
    throw new Error(`Failed to create client credentials IAS token for service ${credentials.label}: ${err.responseText || err.message}, Service instance id=${serviceInstanceId}`);
  }
}

async function exchangeToken(loginToken, correlationId, externalServiceCredentials, cb) {
  try {
    const tokenDecoded = loginToken && loginToken.length > 100 ? jwtDecode(loginToken) : null;
    const tenant = tokenDecoded && tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn;
    const apptid = tokenDecoded && (tokenDecoded.app_tid || tokenDecoded.zone_uuid);
    const authService = createAuthService(externalServiceCredentials);
    const tokenResponse = await authService.fetchJwtBearerToken(loginToken, { correlationId, tenant, zid: apptid , timeout });
    cb(null, tokenResponse.access_token, tokenResponse);
  } catch (err) {
    cb(new Error(`Failed to exchange token: ${err.responseText || err.message}, token details - ${JSON.stringify(getTokenInfo(loginToken))}, external service credentials details - identityzone: ${externalServiceCredentials.identityzone} clientid: ${externalServiceCredentials.clientid}`));
  }
}

async function getClientCredentialsToken(tenant, correlationId, credentials, apptid) {
  const authService = createAuthService(credentials);
  try {
    const tokenResponse = await authService.fetchClientCredentialsToken({ correlationId, tenant, zid: apptid , timeout });
    return handleClientCredentialsTokenResponse(
      createTokenResponseOptions(null, tokenResponse, credentials.label, tenant, correlationId)
    );
  } catch (err) {
    return  handleClientCredentialsTokenResponse(
      createTokenResponseOptions(err, null, credentials.label, tenant, correlationId)
    );
  }
}

function deleteTokenCache(tokenKey) {
  if (tokenCache[tokenKey]) {
    delete tokenCache[tokenKey];
  }
}

async function getPasswordUserToken(tenant, userCreds, credentials, correlationId) {
  const tokenKey = tenant + userCreds.name + userCreds.pass;
  if (tokenCache[tokenKey] && tokenCache[tokenKey].tokenRefreshTimestamp > Date.now()) {
    return tokenCache[tokenKey];
  }
  const authService = createAuthService(credentials);
  try {
    const tokenResponse = await authService.fetchPasswordToken(userCreds.name, userCreds.pass, { correlationId, tenant , timeout });
    const tokenResponseOptions = handleUserTokenResponse(
      createTokenResponseOptions(null, tokenResponse, credentials.label, tenant, correlationId), tokenResponse
    );
    tokenCache[tokenKey] = tokenResponseOptions;
    return tokenResponseOptions;
  } catch (err) {
    throw new Error(`Error getting user token for ${credentials.label} from subaccount ${tenant} error: ${err.message}`);
  }
}

function getRefreshToken(accessToken, uaaOptions) {
  const requestOptions = {
    url: uaaOptions.tokenURL,
    headers: {
      'content-type': 'application/x-www-form-urlencoded;charset=utf-8',
      'accept': 'application/json;charset=utf-8',
      'Authorization': `Bearer ${accessToken}`
    },
    form: {
      'client_id': uaaOptions.clientid,
      'grant_type': 'user_token',
      'token_format': 'jwt'
    }
  };
  return new Promise((resolve, reject) => {
    request.post(requestOptions, (err, res, body) => {
      if (err || res.statusCode !== 200) {
        return reject(`Failed to create refresh token ${err ? err : res.response && res.response.data}`);
      }
      if (!body) {
        return reject('Refresh token missing in response from XSUAA');
      }
      try {
        const tokenData = JSON.parse(body);
        tokenData.refresh_token ? resolve(tokenData) : reject(`Failed to parse token ${body}`);
      } catch (err) {
        reject(`Failed to parse refresh token ${err}`);
      }
    });
  });
}

function createTokenResponseOptions(err, token, serviceName, subaccount, correlationId) {
  return {
    err: err,
    accessToken: token && token.access_token,
    expiration: token && token.expires_in,
    tokenType: token && token.token_type,
    serviceName: serviceName,
    subaccount: subaccount,
    correlationId: correlationId
  };
}

function handleClientCredentialsTokenResponse(tokenResponseOptions) {
  if (tokenResponseOptions.err) {
    return {
      errorMessage: `Error getting client_credentials token for ${tokenResponseOptions.serviceName} from subaccount ${tokenResponseOptions.subaccount} error: ${tokenResponseOptions.err.message}`
    };
  }
  if (!tokenResponseOptions.accessToken || !tokenResponseOptions.expiration) {
    return {
      errorMessage: new Error(`Bad response from UAA when getting client credentials token for ${tokenResponseOptions.serviceName} - not all fields are present`)
    };
  }
  if (process.env.MINIMUM_TOKEN_VALIDITY && tokenResponseOptions.expiration < process.env.MINIMUM_TOKEN_VALIDITY) {
    return {
      errorMessage: new Error(`Token validity for service ${tokenResponseOptions.serviceName} in subaccount ${tokenResponseOptions.subaccount} is lower than the minimum token validity of ${process.env.MINIMUM_TOKEN_VALIDITY} seconds, please increase token validity above this value. To set the token validity on subaccount level refer to: https://api.sap.com/api/SecuritySettingsAPI/resource`)
    };
  }
  tracer.info(`Token validity for service ${tokenResponseOptions.serviceName} in subaccount ${tokenResponseOptions.subaccount} with correlationId ${tokenResponseOptions.correlationId} is ${tokenResponseOptions.expiration}`);
  return createTokenOptions(
    tokenResponseOptions.accessToken,
    tokenResponseOptions.tokenType,
    passportUtils.getExpiresAt(tokenResponseOptions.expiration).getTime()
  );
}

function handleUserTokenResponse(tokenResponseOptions, tokenDecoded) {
  if (tokenResponseOptions.err) {
    return {
      errorMessage: `Error getting user token for ${tokenResponseOptions.serviceName} from subaccount ${tokenResponseOptions.subaccount} error: ${tokenResponseOptions.err.message}`
    };
  }
  if (!tokenResponseOptions.accessToken || !tokenResponseOptions.expiration) {
    return {
      errorMessage: new Error(`Bad response from UAA when user token for ${tokenResponseOptions.serviceName} - not all fields are present`)
    };
  }
  tracer.info(`Token validity for service ${tokenResponseOptions.serviceName} in subaccount ${tokenResponseOptions.subaccount} with correlationId ${tokenResponseOptions.correlationId} is ${tokenResponseOptions.expiration}`);
  const tokenInfo = getTokenInfo(tokenDecoded.access_token);
  Object.assign(tokenDecoded, {
    exp: tokenInfo.expiration,
    roleCollections: tokenInfo.roleCollections
  });
  return createTokenOptions(
    tokenResponseOptions.accessToken,
    tokenResponseOptions.tokenType,
    passportUtils.getExpiresAt(tokenResponseOptions.expiration).getTime(),
    tokenDecoded
  );
}

async function checkSecurityContext(token, conf) {
  const { credentials, type, correlationId } = conf;
  const authService = createAuthService(credentials,type);
  try {
    return await authService.createSecurityContext(token,{correlationId});
  } catch (error) {
    throw new Error(`Failed to create security context: ${error.message}`);
  }
}

function createTokenOptions(accessToken, tokenType, timeStamp, tokenDecoded) {
  return { accessToken, tokenType, tokenRefreshTimestamp: timeStamp, tokenDecoded };
}