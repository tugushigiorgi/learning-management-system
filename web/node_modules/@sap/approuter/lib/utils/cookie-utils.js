'use strict';

const crypto = require('crypto');
const querystring = require('querystring');
const tough = require('tough-cookie');
const uaaUtils = require('./uaa-utils');
const pathUtil = require('./path-util');
const iasUtils = require('./ias-utils');
const cookie = require('cookie');
const uuid = require('uuid');
const state = require('../passport/state');

const SESSION_SECRET_LENGTH = 64;
let __toString = Object.prototype.toString;


module.exports.isDynamicPartition = function (req) {
  const secHeaderValue = req && req.headers && (req.headers['sec-fetch-storage-access'] || req.headers['Sec-Fetch-Storage-Access']);
  return secHeaderValue === 'none' || secHeaderValue === 'inactive';
};

exports.generateSessionSecret = function () {
  return crypto.randomBytes(SESSION_SECRET_LENGTH).toString('hex');
};

exports.getBackendCookiesSecret = function () {
  return process.env.BACKEND_COOKIES_SECRET || exports.generateSessionSecret();
};

exports.getExternalStoreSessionSecret = function (extSessionMgt) {
  return extSessionMgt && extSessionMgt.sessionSecret;
};

const resizedIV = Buffer.allocUnsafe(16);
const iv = crypto
  .createHash('sha256')
  .update(exports.getBackendCookiesSecret())
  .digest();
iv.copy(resizedIV);
const key = crypto
  .createHash('sha256')
  .update(exports.getBackendCookiesSecret())
  .digest();

exports.setCookie = function (res, cookie) {
  const oldCookies = res.getHeader('set-cookie');
  res.setHeader('set-cookie', oldCookies ? [].concat(oldCookies, cookie) : cookie);
};

exports.getSessionCookieName = function () {
  // This cookie name 'JSESSIONID' tells Cloud Foundry to use session stickiness
  // https://docs.cloudfoundry.org/devguide/deploy-apps/prepare-to-deploy.html#sessions
  // https://github.com/cloudfoundry/gorouter/issues/26
  return getCookieName('AR-', 'JSESSIONID');
};

exports.getPlatformCookieName = function (){
  const cookieName = process.env.PLATFORM_COOKIE_NAME || '__VCAP_ID__';
  return getCookieName('', cookieName);
};

exports.getRedirectLocationCookieName = function () {
  return getCookieName('ARLOC-', 'locationAfterLogin');
};

exports.getFragmentCookieName = function () {
  return getCookieName('ARFRG-', 'fragmentAfterLogin');
};

exports.getBackendCookieName = function () {
  return getCookieName('ARBE-', 'ARBE');
};

exports.isBrowserRequest = function (req){
  const userAgent = req.headers['user-agent'];
  return userAgent && userAgent.includes('Mozilla');
};

exports.addStaleSessionCookies = function (req, res) {
  const sessionCookieName = req.app && req.app.get('cookieName');

  // Filter cookies to find the session cookies
  const existingSessionRelatedCookies = req.headers.cookie && req.headers.cookie.split(';').filter(n => n.trim().startsWith(sessionCookieName + '=')) || [];

  // Filter out state cookies
  const existingSessionCookies = existingSessionRelatedCookies.filter(cookie => !state.isActiveStateCookie(cookie));

  const cookieConfig = req.routerConfig && req.routerConfig.cookies || {};
  const { Partitioned : partitioned , SameSite :sameSite } = cookieConfig;
  let staleCookiesFound = false;
  existingSessionCookies.forEach(sessionCookie => {
    const [name, value] = sessionCookie.split('=');
    const cookieOptionsBase = {
      path: '/',
      httpOnly: true,
      secure: true,
      maxAge: 0,
      sameSite
    };
    const partitionedValues = [!!partitioned, !partitioned];
    partitionedValues.forEach((partitionedValue) => {
      const cookieOptions = Object.assign({}, cookieOptionsBase, { partitioned: partitionedValue });
      const oldSessionCookie = cookie.serialize(name.trim(), value, cookieOptions);
      exports.setCookie(res, oldSessionCookie);
    });
    staleCookiesFound = true;
  });

  return staleCookiesFound;
};

exports.shouldPartitionCookie = function (req) {
  const logger = req && req.logger;
  const partitionedConfig = req.routerConfig && req.routerConfig.cookies && req.routerConfig.cookies['Partitioned'];
  partitionedConfig && logger && logger.debug(`Partitioned config: ${JSON.stringify(partitionedConfig)}`);
  const setDynamicPartition = exports.isDynamicPartition(req);
  logger && logger.debug(`Dynamic partition: ${setDynamicPartition}`);
  const userAgent = req.headers && req.headers['user-agent'] || '';
  return userAgent && partitionedConfig && (userAgent.match(partitionedConfig.supportedPartitionAgents) && !userAgent.match(partitionedConfig.unsupportedPartitionAgents)) || setDynamicPartition;
};

exports.addSessionCookie = function (req, res) {
  const sessionCookieName = req.app && req.app.get('cookieName');
  const cookieConfig = req.routerConfig && req.routerConfig.cookies || {};
  const { SameSite :sameSite } = cookieConfig;
  const sessionCookieValue = uuid.v4();
  req.state = sessionCookieValue;
  const cookieOptions = { path: '/', httpOnly: true, secure: true, sameSite };
  if (this.shouldPartitionCookie(req)) {
    cookieOptions.partitioned = true;
  }
  const sessionCookie = cookie.serialize(sessionCookieName, sessionCookieValue, cookieOptions);
  this.setCookie(res, sessionCookie);
};

/*
  * This function is used to set the session cookie for deletion.
  * It sets the maxAge to 0, which will cause the browser to delete the cookie.
  * It fails gracefully if an error occurs.
 */
exports.setSessionCookieForDeletion = function (req, res) {
  const sessionCookieName = exports.getSessionCookieName(req);
  const cookieOptions = {
    path: '/',
    expires: new Date(0),
    httpOnly: true,
    secure: true,
    maxAge: 0
  };

  try {
    const sessionCookie = exports.serialize(req, sessionCookieName, '', cookieOptions);
    exports.setCookie(res, exports.addAttributes(sessionCookie, req));
  } catch (e) {
    req.logger && req.logger.error(`Error setting session cookie for deletion ${e.message}`);
  }
};

function getCookieName(prefix, defaultCookieName) {
  if ('USE_JSESSION_COOKIE_SUFFIX_REQUIRED' in process.env && process.env.VCAP_APPLICATION) {
    // With port based routing the session cookies of two app router applications may
    // overwrite/reuse each other if the browser ignores the port of the applications
    const vcapApplication = JSON.parse(process.env.VCAP_APPLICATION);
    if (vcapApplication.application_id) {
      return prefix + compactGuid(vcapApplication.application_id);
    }
  }
  return defaultCookieName;
}

function compactGuid(guid) {
  return guid.split('-').map(function (segment) {
    return parseInt(segment, 16).toString(36);
  }).join('');
}

exports.signCookie = function (req, value, cb) {
  if (req && pathUtil.pathAuthenticationType(req) === 'ias' && iasUtils.getIasCredentials(req)) {
    iasUtils.getIasConfig(req, function (err, iasOptions) {
      if (err) {
        return cb(err);
      }
      return encrypt(value, iasOptions, cb);
    });
  } else {
    uaaUtils.getUaaConfig(req, function (err, uaaOptions) {
      if (err) {
        return cb(err);
      }
      return encrypt(value, uaaOptions, cb);
    });
  }
};

exports.verifyCookie = function (req, value, signature, cb) {
  exports.signCookie(req, value, function (err, hash) {
    if (err) {
      return cb(err);
    }
    if (signature && signature.includes(hash)) {
      cb();
    } else {
      cb('Signature does not match');
    }
  });
};

// See: https://nodejs.org/en/knowledge/cryptography/how-to-use-crypto-module/
exports.encryptCookies = function (cookies, backendName) {
  const msg = [];
  const cipher = crypto.createCipheriv('aes256', key, resizedIV);
  msg.push(cipher.update(JSON.stringify({[backendName]: cookies.map(cookie => cookie.key + '=' + cookie.value)}), 'binary', 'hex'));
  msg.push(cipher.final('hex'));
  return exports.getBackendCookieName() + '=' + msg.join('') + '; Path=/; HttpOnly;';
};

exports.decryptCookies = function (cookies, backendName, logger) {
  logger && logger.info('Cookies %s are decrypted for backendName %s', cookies, backendName);
  let idx = -1;
  const msg = [];
  const backendCookieName = exports.getBackendCookieName();
  const splitCookies = cookies.split(';');
  const parsedCookies = splitCookies.map(cookie => tough.Cookie.parse(cookie));
  const encryptedCookie = parsedCookies.find((cookie, i) => (cookie.key === backendCookieName) && (idx = i) >= 0);
  if (encryptedCookie) {
    parsedCookies.splice(idx, 1);
    try {
      const decipher = crypto.createDecipheriv('aes256', key, resizedIV);
      msg.push(decipher.update(encryptedCookie.value, 'hex', 'binary'));
      msg.push(decipher.final('binary'));
    } catch (err) {
      logger && logger.info('Failed to decrypt cookie with key %s and value %s', encryptedCookie.key, encryptedCookie.value);
      return parsedCookies.join(';');
    }
    const messageValToJson = JSON.parse(msg.join(''));
    if (!messageValToJson[backendName]){
      const arbeBackendName = Object.keys(messageValToJson)[0];
      logger && logger.info('Backend %s not found in ARBE cookie which belongs to backend %s ', backendName, arbeBackendName);
    }
    else {
      const reducedValue = messageValToJson[backendName].reduce(onReduce, []);
      const itemToPush = reducedValue.join('; ');
      parsedCookies.push(itemToPush);
    }
    return parsedCookies.join(';');
  } else {
    return cookies;
  }
};

exports.getBackendName = function (req) {
  return req && req.internalUrl && req.internalUrl.route &&
      (req.internalUrl.route.destination || req.internalUrl.route.service);
};

exports.addSamesite = function (cookie, sameSite) {
  if (sameSite) {
    let sameSiteString = ';Secure;SameSite=' + sameSite + ';";';
    cookie = cookie.endsWith('";') ? cookie.slice(0, -2) + sameSiteString : cookie + sameSiteString.slice(0, -2);
  }
  return cookie;
};

exports.addAttributes = function (cookie, req) {
  const attrs = [];
  const opts = Object.assign({}, req.routerConfig && req.routerConfig.cookies);
  const partitionedAllowed = this.shouldPartitionCookie(req);
  if (opts.SameSite === 'None' || partitionedAllowed) {
    cookie = cookie.replaceAll(/;\s*Secure\s*(;|$)/gi, ';');
    attrs.push('Secure');
  }
  if (opts.SameSite) {
    cookie = cookie.replaceAll(/;\s*SameSite\s*=\s*[^;]*(;|$)/gi, ';');
    attrs.push('SameSite=' + opts.SameSite);
  }
  if (partitionedAllowed){
    cookie = cookie.replaceAll(/;\s*Partitioned\s*(;|$)/gi, ';');
    attrs.push('Partitioned');
  }
  const endsWithSemicolon = /;\s*$/.test(cookie);
  const quoted = cookie.match(/"\s*;\s*$/);
  return (quoted ? cookie.slice(0, -quoted[0].length) : cookie) + (endsWithSemicolon && !quoted ? '' : ';') + attrs.join(';') + (quoted ? '";' : '');
};

exports.serialize = function (req, name, val, options) {

  let logger = req.logger;
  try {
    try {
      return cookie.serialize(name, val, options);
    } catch (e) {
      if (req && req.routerConfig && req.routerConfig.cookieBackwardCompatibility) {
        logger && logger.info(`Illegal content in cookie ${name}, using backward compatible cookie serialization`);
        return exports.internalSerialize(name, val, options);
      }
      const message = e.message || `error serializing cookie ${name}`;
      logger && logger.error(`Illegal content in cookie: ${name}, you may want to set environment variable COOKIE_BACKWARD_COMPATIBILITY to true for backward compatible validation, ${message}`);
      throw e;
    }
  }
  catch (e) {
    logger && logger.error(`Error in backward compatible cookie serialization for cookie ${name}`);
    throw e;
  }
};

function encode (val) {
  return encodeURIComponent(val);
}

function isDate (val) {
  return __toString.call(val) === '[object Date]' ||
      val instanceof Date;
}

exports.internalSerialize = function (name, val, options) {
  // eslint-disable-next-line no-control-regex
  const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

  let opt = options || {};
  let enc = opt.encode || encode;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!fieldContentRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  let value = enc(val);

  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  let str = name + '=' + value;

  // eslint-disable-next-line eqeqeq
  if (null != opt.maxAge) {
    let maxAge = opt.maxAge - 0;

    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid');
    }

    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    let expires = opt.expires;

    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.partitioned) {
    str += '; Partitioned';
  }

  if (opt.priority) {
    let priority = typeof opt.priority === 'string'
      ? opt.priority.toLowerCase()
      : opt.priority;

    switch (priority) {
    case 'low':
      str += '; Priority=Low';
      break;
    case 'medium':
      str += '; Priority=Medium';
      break;
    case 'high':
      str += '; Priority=High';
      break;
    default:
      throw new TypeError('option priority is invalid');
    }
  }

  if (opt.sameSite) {
    let sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
    case true:
      str += '; SameSite=Strict';
      break;
    case 'lax':
      str += '; SameSite=Lax';
      break;
    case 'strict':
      str += '; SameSite=Strict';
      break;
    case 'none':
      str += '; SameSite=None';
      break;
    default:
      throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
};

function encrypt(value, options, cb) {
  if (!options || (!options.clientsecret && !options.clientid)) {
    return cb('Invalid UAA options');
  }
  const encryptionKey = options.clientsecret || options.clientid;
  const hash = crypto
    .createHash('sha1')
    .update(value + '-' + encryptionKey, 'ascii')
    .digest('base64');
  return cb(null, querystring.escape(hash));
}

function onReduce (allCookies, cookie){
  let parsedCookie = tough.Cookie.parse(cookie);
  if (parsedCookie) {
    const {key, value} = parsedCookie;
    allCookies.push(key + '=' + value);
  }
  return allCookies;
}