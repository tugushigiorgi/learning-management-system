'use strict';

const tracer = require('../utils/logger').getTracer(__filename);
const Redis = require('ioredis');
const REDIS_SCALE_READS = process.env.REDIS_SCALE_READS || 'all';
const vcapUtils = require('../utils/vcap-utils');

class RedisClientDriver {
  constructor(extSessionMgt) {
    this.defaultRetryTimeout = extSessionMgt.defaultRetryTimeout || 2000;
    this.backOffMultiplier = extSessionMgt.backOffMultiplier || 50;
    this.skipCertHostnameValidation = extSessionMgt.skipCertHostnameValidation;

    this.credentials = vcapUtils.getServiceCredentials({ name: extSessionMgt.instanceName });
    this.parseCredentials();

    this.init();
  }

  parseCredentials() {
    if (this.credentials.tls && typeof this.credentials.tls === 'string') {
      this.credentials.tls = JSON.parse(this.credentials.tls);
    }
    if (this.credentials.sentinel_nodes && typeof this.credentials.sentinel_nodes === 'string') {
      // eslint-disable-next-line camelcase
      this.credentials.sentinel_nodes = JSON.parse(this.credentials.sentinel_nodes);
    }
    if (this.credentials.cluster_mode && typeof this.credentials.cluster_mode === 'string') {
      // eslint-disable-next-line camelcase
      this.credentials.cluster_mode = JSON.parse(this.credentials.cluster_mode);
    }
  }

  init() {
    try {
      this.client = this.credentials.cluster_mode ? this.initializeClusterClient() : this.initializeClient();
      this.client.on('error', (err) => {
        tracer.error(`initClient - Redis connection error, err.code ${ err.code }, err: ${ err.message }`);
        if (err && err.code === 'ECONNREFUSED') {
          tracer.error('initClient - onError - The server refused the connection');
        }
      });
      this.client.on('connect', () => {
        tracer.debug('initClient - Redis connected');
      });
    } catch (err) {
      tracer.error(`RedisClientDriver error: ${ err.message }`);
      this.client = null;
    }
  }

  getClient() {
    if (!this.client || this.client.closing) {
      this.init();
    }
    return this.client;
  }

  initializeClient() {
    const redisOptions = {};
    if (this.credentials.ca_base64) {
      redisOptions.tls = { ca: Buffer.from(this.credentials.ca_base64, 'base64').toString('utf-8') };
    } else if (this.credentials.tls) {
      redisOptions.tls = {
        host: this.credentials.hostname || this.credentials.tls.host || this.credentials.tls.hostname,
        port: this.credentials.port || this.credentials.tls.port
      };

      if (this.credentials.tls.server_ca) {
        redisOptions.tls.ca = this.credentials.tls.server_ca;
      }
      if (this.credentials.tls.ca) {
        redisOptions.tls.ca = this.credentials.tls.ca;
      }
      if (this.credentials.tls.sslrootcert && this.credentials.tls.sslcert) {
        redisOptions.tls.ca = this.credentials.tls.sslrootcert;
        redisOptions.tls.cert = this.credentials.tls.sslcert;
      }

      if (this.skipCertHostnameValidation) {
        redisOptions.tls.checkServerIdentity = (/* host, cert*/) => {
          // skip certificate hostname validation
          return undefined;
        };
      }

      redisOptions.username = this.credentials.username;
      redisOptions.password = this.credentials.password;
    } else if (this.credentials.sentinel_nodes && this.credentials.sentinel_nodes.length > 0) {
      redisOptions.name = (this.credentials.uri && this.credentials.uri.split('#')[1]) || 'mymaster';
      redisOptions.sentinels = this.credentials.sentinel_nodes.map(node => ({
        port: node.port,
        host: node.hostname
      }));
      redisOptions.password = this.credentials.password;
      redisOptions.sentinelPassword = this.credentials.password;
    } else {
      redisOptions.host = this.credentials.hostname;
      redisOptions.port = this.credentials.port;
      redisOptions.password = this.credentials.password;
    }

    redisOptions.retryStrategy = this.retryStrategy.bind(this);

    redisOptions.showFriendlyErrorStack = process.env.DEV_ENV_TRACES === 'true';

    redisOptions.maxRetriesPerRequest = 2;

    redisOptions.enableAutoPipelining = true;

    tracer.debug(`initializeClient - Initializing with options: ${ JSON.stringify(
      // eslint-disable-next-line eqeqeq
      redisOptions, (key, value) => key === 'password' && value != null ? '***' : value, 2) }`);

    return new Redis(redisOptions);
  }

  retryStrategy(times) {
    tracer.debug(`addRetryStrategy - retryStrategy times ${ times }`);
    let timeout;
    if (times < 3) {
      timeout = Math.min(times * this.backOffMultiplier, this.defaultRetryTimeout);
    } else {
      this.client = null;
    }
    return timeout;
  }

  initializeClusterClient() {
    const host = this.credentials.hostname || this.credentials.tls.host || this.credentials.tls.hostname;
    const port = this.credentials.port || this.credentials.tls.port;
    const startupNodes = [ { host, port } ];
    const redisOptions = {
      tls: (this.credentials.tls === true ? {} : { host, port }),
      password: this.credentials.password,
      enableAutoPipelining: true
    };

    tracer.debug(`initializeClusterClient - initializeClusterClient startup nodes - ${ JSON.stringify(startupNodes) }, options - ${ JSON.stringify(
      // eslint-disable-next-line eqeqeq
      redisOptions, (key, value) => key === 'password' && value != null ? '***' : value, 2) }`);

    return new Redis.Cluster(startupNodes, {
      dnsLookup: (address, callback) => callback(null, address),
      scaleReads: REDIS_SCALE_READS,
      clusterRetryStrategy: this.retryStrategy.bind(this),
      redisOptions
    });
  }
}

module.exports.RedisClientDriver = RedisClientDriver;

let redisDriver;

module.exports.getClient = (extSessionMgt) => {
  if (!redisDriver) {
    redisDriver = new RedisClientDriver(extSessionMgt);
  }

  return redisDriver.getClient();
};
