'use strict';

const _ = require('lodash');
const loggingUtils = require('./logger');
const logger = loggingUtils.getLogger('/Destination service');
const vcapUtils = require('./vcap-utils');
const request = require('./request-utils');
const tokenUtils = require('./token-utils');
const headerUtils = require('./header-util');
const validator = require('validator');
const NodeCache = require('node-cache');
const logRequestInfo = require('./application-logs-utils').logRequestInfo;
const stdTTL = process.env.SERVICE_DESTINATION_CACHE_TTL || 300;
const serviceInstanceDestinationsCache = new NodeCache({stdTTL: stdTTL, checkperiod: 16});
const DESTINATION = 'destination';
const AUTH_CLIENT_CERT = 'ClientCertificateAuthentication';
const PRIVATE_LINK = 'PrivateLink';
const INTERNET = 'Internet';
const HttpKeepAliveAgent = require('agentkeepalive');
const HttpsKeepAliveAgent = HttpKeepAliveAgent.HttpsAgent;
const httpsPrivateLinkAgent = new HttpsKeepAliveAgent();
const httpsInternetProxyAgent = new HttpsKeepAliveAgent();
const { promisify }  = require('util');

exports.adjustDestinationProperties = adjustDestinationProperties;
exports.normalizeDestinationProperties = normalizeDestinationProperties;
exports.getDestinationServiceCredentials = getDestinationServiceCredentials;
exports.findDestination = findDestination;
exports.getDestinationsByTenant = getDestinationsByTenant;
exports.getDestinationsByDestinationKey = getDestinationsByDestinationKey;
exports.getServiceInstanceDestinationsByTenant = getServiceInstanceDestinationsByTenant;
exports.getHttpRequestOptions = getHttpRequestOptions;
exports.getDestinationCertificate = getDestinationCertificate;
exports.normalizeCertificateProperties = normalizeCertificateProperties;
exports.isDestinationCertificatesFlow = isDestinationCertificatesFlow;
exports.rejectUnauthorized = rejectUnauthorized;
exports.getDestinationCredentialsByDestinationKey = getDestinationCredentialsByDestinationKey;
exports.executeInChunks = executeInChunks;
exports.useIASToken = useIASToken;

function rejectUnauthorized(destination){
  const { strictSSL , trustAll , proxyType } = destination;
  return (proxyType === PRIVATE_LINK) ? !(trustAll === true) : !(strictSSL === false);
}

function isDestinationCertificatesFlow(destination) {
  const {authentication, trustStoreLocation} = destination;
  return (authentication === AUTH_CLIENT_CERT || trustStoreLocation) ? true : false;
}

function normalizeCertificateProperties(certificates) {
  if (!certificates) {
    return null;
  }
  const clonedCertificates = _.clone(certificates);
  clonedCertificates.forEach((certificate) => {
    for (const certificateKey in certificate) {
      certificate[certificateKey.toLowerCase()] = certificate[certificateKey];
      delete certificate[certificateKey];
    }
  });
  return clonedCertificates;
}

function parseTextFormat(content) {
  let ca = '';
  const pem = Buffer.from(content, 'base64').toString('ascii');
  const keySeparator = pem => pem.match(/([-]+END [^\\s]+ PRIVATE KEY[-]+)|([-]+END PRIVATE KEY[-]+)/);
  const separator = keySeparator(pem);
  if (separator) {
    const separated = pem.split(separator[0]);
    ca = separated[1];
  } else {
    ca = pem;
  }
  return ca;
}

function getHttpRequestOptions(destination, opts) {
  if (!destination.certificates) {
    return opts;
  }
  for (const certificate of destination.certificates) {
    if (certificate.trustCertificate) {
      logger.info('Sending trusted pem certificate to backend');
      opts.ca = certificate.ca;
      if (destination.proxyType === PRIVATE_LINK && !process.env.SAAS_APPROUTER) {
        httpsPrivateLinkAgent.options.ca = certificate.ca;
        opts.agent = httpsPrivateLinkAgent;
      }
      if (destination.proxyType === INTERNET) {
        httpsInternetProxyAgent.options.ca = certificate.ca;
        opts.agent = httpsInternetProxyAgent;
      }
    }
    if (certificate.clientCertificate) {
      switch (certificate.type) {
      case 'p12':
        logger.info('Sending p12 certificate to backend');
        opts.pfx = certificate.buffer;
        opts.passphrase = certificate.passphrase;
        // if certificate provided by XSUUA or IAS should be deleted
        opts.cert && delete opts.cert;
        opts.key && delete opts.key;
        break;
      case 'pem':
        logger.info('Sending pem certificate to backend');
        opts.cert = certificate.cert;
        opts.key = certificate.key;
        break;
      }
    }
  }
  return opts;
}

function getDestinationCertificate(destinationConfiguration, certificates) {
  const {keyStoreLocation, keyStorePassword, trustStoreLocation, authentication} = destinationConfiguration;
  const certificatesResult = [];

  certificates.forEach((certificate) => {
    const {content, name} = certificate;
    const extension = name.split('.').pop();
    if (name === keyStoreLocation && authentication === AUTH_CLIENT_CERT) {
      if (extension !== 'p12') {
        // extension comes from user destination configuration, so this log the error and sanitizes the input
        throw new Error(`unsupported certificate format, expected p12 but received ${extension.length > 5 ? extension.substring(0, 5) + '...' : extension}`);
      }
      certificatesResult.push(
        {
          clientCertificate: true,
          buffer: Buffer.from(content, 'base64'),
          passphrase: keyStorePassword,
          type: extension
        }
      );
    } else if (name === trustStoreLocation) {
      if (extension !== 'pem') {
        // extension comes from user destination configuration, so this log the error and sanitizes the input
        throw new Error(`unsupported certificate format, expected pem but received ${extension.length > 5 ? extension.substring(0, 5) + '...' : extension}`);
      }
      certificatesResult.push(
        {
          trustCertificate: true,
          ca: parseTextFormat(content),
          type: extension
        }
      );
    }
  });
  return certificatesResult.length > 0 ? certificatesResult : null;
}

function getServiceInstanceDestinationsByTenant(req, cb) {
  const getDestinationPromises = [];
  let serviceInstanceDestinations = serviceInstanceDestinationsCache.get(req.tenant);
  if (serviceInstanceDestinations) {
    return cb(null, serviceInstanceDestinations);
  }
  serviceInstanceDestinations = [];
  getDestinationInstanceCredentialsByTenant(req, function (err, tenantDestinations) {
    if (err) {
      return cb(err);
    }
    if (!tenantDestinations || tenantDestinations.length === 0) {
      return cb(null, serviceInstanceDestinations);
    }
    tenantDestinations.forEach((tenantDestination) => {
      getDestinationPromises.push(
        new Promise((resolve, reject) => {
          const destinationKey = req.tenant + '_' + tenantDestination.Name;
          getDestinationsByDestinationKey(req.app, destinationKey,tenantDestination, headerUtils.getCorrelationId(req), false, function (err, destinations) {
            if (err) {
              reject(err);
            } else {
              resolve(destinations);
            }
          });
        })
      );
    });
    // Execute promises in chunks of 50 with a 1-second delay
    const chunkSize = process.env.FETCH_DESTINATIONS_CHUNK_SIZE || 50;
    const delay = process.env.FETCH_DESTINATIONS_CHUNK_DELAY || 1000;
    executeInChunks(getDestinationPromises, chunkSize, delay)
      .then((values) => {
        values.forEach((instanceDestinations) => {
          if (instanceDestinations) {
            serviceInstanceDestinations.push(...instanceDestinations);
          }
        });
        serviceInstanceDestinationsCache.set(req.tenant, serviceInstanceDestinations);
        cb(null, serviceInstanceDestinations);
      }).catch ((reason) =>  {
        cb(reason);
      });
  });
}

function getDestinationInstanceCredentialsByTenant(req, cb) {
  const token = req.app && req.app.services && req.app.services[DESTINATION] && req.app.services[DESTINATION].token;
  const tenantDestinationsMap = new Map();
  const tenant =  req.tenant.toLowerCase();
  exports.getDestinationsByTenant(headerUtils.getCorrelationId(req), tenant, token, req.zoneInfo, req.app.services, false,function (err, destinations) {
    if (err) {
      return cb(err);
    }
    destinations.forEach((destination) => {
      const nameParts = destination.Name.split('_');
      const destSubdomain = nameParts.length === 2 && nameParts[0];
      const destInstId = nameParts.length === 2 ? nameParts[1] : destination.Name;
      if (destSubdomain === tenant && validator.isUUID(destInstId, 4)) {
        destination.migrated = true;
        destination.Name = destInstId;
        tenantDestinationsMap.set(destination.Name, destination);
      } else if (!destSubdomain && validator.isUUID(destInstId, 4) && destination.tokenServiceURL &&
          tenant === destination.tokenServiceURL.substring(8, destination.tokenServiceURL.indexOf('.'))) {
        tenantDestinationsMap.set(destination.Name, destination);
      }
    });
    cb(null, Array.from(tenantDestinationsMap.values()));
  });
}

async function getDestinationsByDestinationKey(app, destinationKey,destinationConfiguration, correlationId, runtimeFlow, cb) {
  let destinationToken = app.services && app.services[destinationKey] && app.services[destinationKey].token;
  let credentials;
  let response;
  if (!destinationToken || destinationToken.tokenRefreshTimestamp - Date.now() <= 0 || !app.services[destinationKey].credentials) {
    if (destinationConfiguration) {
      credentials = {
        url: destinationConfiguration.tokenServiceURL,
        clientid: destinationConfiguration.clientId,
        clientsecret: destinationConfiguration.clientSecret
      };
    } else {
      // eslint-disable-next-line no-unused-vars
      const destinationId = destinationKey.split('_')[1];
      const findDestinationPromise = promisify(findDestination);
      try {
        response = await findDestinationPromise(destinationKey, null, {app: app, correlationId: correlationId});
      } catch (err) {
        logger.error(`No destination found for destination key ${destinationKey}, fallback to destinationId ${destinationId}, error: ${err}`);
        try {
          response = await findDestinationPromise(destinationId, null, {app: app, correlationId: correlationId});
        } catch (err) {
          return cb('Failed to get subaccount destination by destination key for destination key ' + destinationKey + ' ' + err);
        }
      }

      if (!response || !response.destinationConfiguration) {
        return cb(`Failed to get subaccount destination by destination key for destination key ${destinationKey}`);
      }

      credentials = {
        url: response.destinationConfiguration.tokenServiceURL,
        clientid: response.destinationConfiguration.clientId,
        clientsecret: response.destinationConfiguration.clientSecret
      };
    }

    const loadClientCredentialsToken = promisify(tokenUtils.loadClientCredentialsToken);
    const [subdomain, destinationId] = destinationKey.split('_');
    credentials.identityzone = subdomain;
    try {
      await loadClientCredentialsToken(app, correlationId, credentials, destinationKey);
    } catch (err) {
      const message = `Error while fetching client_credentials token for destination service instance ${destinationId} from subdomain ${subdomain} ${err}`;
      if (runtimeFlow) {
        return cb(message);
      } else {
        logger.error(message);
        return cb();
      }
    }
    destinationToken = app.services && app.services[destinationKey] && app.services[destinationKey].token;
    app.services[destinationKey].credentials = destinationConfiguration || (response && response.destinationConfiguration);
    return getDestinationsByServiceInstance(destinationToken, destinationKey, app.services, cb);
  } else {
    return getDestinationsByServiceInstance(destinationToken, destinationKey, app.services, cb);
  }
}

function getDestinationCredentialsByDestinationKey(app, destinationKey, correlationId, cb) {
  if (!app || !app.services || !destinationKey || !app.services[destinationKey]){
    return cb('Invalid input parameters for getting destination credentials by destinationKey');
  }
  if (!app.services[destinationKey].credentials) {
    const [subdomain, destinationId] = destinationKey.split('_');
    exports.findDestination(destinationKey, null, {app: app, correlationId: correlationId}, function (err, response) {
      if (err || !response || !response.destinationConfiguration) {
        logger.error(`No destination found for destination key ${destinationKey}, fallback to destinationId ${destinationId}, error: ${err}`);
        exports.findDestination(destinationId, null, {app: app, correlationId: correlationId}, function (err, response) {
          if (err || !response || !response.destinationConfiguration) {
            return cb('Failed to get subaccount destination by destination key for destination Id ' + destinationId + ' in subdomain ' + subdomain + ' ' + err);
          }
          app.services[destinationKey].credentials = response.destinationConfiguration;
          return cb(null, app.services[destinationKey].credentials);
        });
      } else {
        app.services[destinationKey].credentials = response.destinationConfiguration;
        return cb(null, app.services[destinationKey].credentials);
      }
    });
  } else {
    return cb(null, app.services[destinationKey].credentials);
  }
}

function getDestinationsByServiceInstance(token, destinationKey, services, cb) {
  getDestinationsByInstanceReqOptions(token, services, function (err, requestOptions) {
    if (err) {
      return cb('Error while retrieving destinations for service instance ' + destinationKey + err);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        return cb('Error while retrieving destinations for service instance ' + destinationKey + ' ' + (err && err.message));
      }
      if (res.statusCode !== 200 || !res.body) {
        const errorMessage = 'Error while retrieving destinations for service instance ' + destinationKey + ' from destination service. HTTP status code: ' + res.statusCode;
        return cb(errorMessage);
      }
      try {
        const destinationLookUpResult = JSON.parse(res.body);
        destinationLookUpResult.forEach((destination) => {
          destination.destinationId = destinationKey.split('_')[1];
        });
        return cb(null, destinationLookUpResult);
      } catch (err) {
        return cb(err);
      }
    });
  });
}

function getDestinationsByInstanceReqOptions(token, services, cb) {
  const credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb('Destination service is not bound');
  }
  if (!token) {
    return cb('No destination token provided');
  }
  const headers = {'accept': 'application/json;charset=utf-8'};
  headers.Authorization = 'Bearer ' + token.accessToken;
  return cb(null, {
    url: credentials.uri + '/destination-configuration/v1/instanceDestinations',
    headers: headers,
    cache: {services: services, serviceName: DESTINATION},
  });
}

function getDestinationsByTenant(correlationId, tenant, token, zoneInfo, services,fetchSubscriberDest, cb) {
  getDestinationsByTenantReqOptions(correlationId, tenant, token, zoneInfo, services, fetchSubscriberDest,function (error, requestOptions) {
    if (error) {
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        return cb('Error while retrieving destinations for tenant ' + tenant + ' ' + (err && err.message));
      }
      if (res.statusCode !== 200 || !res.body) {
        let errorMessage = 'Error while retrieving destinations for tenant ' + tenant + ' from destination service. HTTP status code: ' + res.statusCode;
        const error = new Error(errorMessage);
        error.status = res.statusCode;
        return cb(error);
      }
      let destinationLookUpResult;
      try {
        destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}

function adjustDestinationProperties(destinations) {
  destinations.forEach(function (destination) {
    if (destination.proxyType === 'OnPremise') {
      try {
        let credentials = vcapUtils.getServiceCredentials({tag: 'connectivity'});
        destination['proxyHost'] = credentials.onpremise_proxy_host;
        destination['proxyPort'] = credentials.onpremise_proxy_port;
      } catch (error) {
        // eslint-disable-next-line no-useless-escape
        throw 'Destination \"' + destination.name +
        // eslint-disable-next-line no-useless-escape
        '\" with  ProxyType \"OnPremise\" but connectivity service is not bound.';
      }
    }
    _.defaults(destination, {
      timeout: 30000
    });
  });
}

function normalizeDestinationProperties(destinations) {
  if (!destinations) {
    return;
  }
  if (!Array.isArray(destinations)) {
    throw new Error('destinations type invalid, array is expected');
  }
  destinations.forEach(function (destination, i, destinations) {
    if (destinations[i].Authentication) { // if it destination from destinations service
      destinations[i] = normalizeDestination(destination);
      destinations[i].forwardAuthToken = destinations[i].forwardAuthToken === 'true' || destinations[i].forwardAuthToken === true;
      destinations[i].forwardAuthCertificates = destinations[i].forwardAuthCertificates === 'true' || destinations[i].forwardAuthCertificates === true;
      destinations[i].preserveHostHeader = destinations[i].preserveHostHeader === 'true' || destinations[i].preserveHostHeader === true;
      destinations[i].dynamicDestination = (destinations[i].hasOwnProperty('dynamicDestination') && destinations[i].dynamicDestination ? destinations[i].dynamicDestination.toLowerCase() === 'true' : false)  || destinations[i].dynamicDestination === true;
      destinations[i].trustAll = destinations[i].trustAll === 'true' || destinations[i].trustAll === true;
      if (destinations[i].hasOwnProperty('setXForwardedHeaders')) {
        destinations[i].setXForwardedHeaders = destinations[i].setXForwardedHeaders === 'true' || destinations[i].setXForwardedHeaders === true;
      }
      if (destinations[i].timeout && !isNaN(destinations[i].timeout)) {
        destinations[i].timeout = _.toSafeInteger(destinations[i].timeout);
      }
    }
  });
}

function getDestinationsByTenantReqOptions(correlationId, tenant, token, zoneInfo, services,fetchSubscriberDest, cb) {
  let credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb('Destination service is not bound');
  }
  let url;
  if (process.env.MIGRATED_DEST === 'true' && !fetchSubscriberDest){
    url = `${credentials.uri}/destination-configuration/v1/subaccountDestinations?$filter=startswith(Name,'${tenant}')`;
  } else {
    url = credentials.uri + '/destination-configuration/v1/subaccountDestinations';
  }
  let headers = {'accept': 'application/json;charset=utf-8'};
  if (token) {
    headers.Authorization = 'Bearer ' + token.accessToken;
    return cb(null, {
      url: url,
      headers: headers,
      cache: {services: services, serviceName: DESTINATION},
    });
  }
  tokenUtils.getClientCredentialsTokenByTenant(correlationId, tenant, credentials, zoneInfo, function (err, token) {
    if (err) {
      return cb(err);
    }
    headers.Authorization = 'Bearer ' + token.accessToken;
    return cb(null, {
      url: url,
      headers: headers
    });
  });
}

function getFindDestinationReqOptions(destinationName, token, options, cb) {
  let credentials = getDestinationServiceCredentials();
  if (!credentials) {
    return cb('Destination service is not bound');
  }
  getDestinationToken(options, token, credentials, (err, options) => {
    if (err) {
      return cb(err);
    }

    let headers = {'accept': 'application/json;charset=utf-8'};
    let auth;
    let shouldCache;
    if (options.userToken && !options.preferLocal) {
      logRequestInfo(options, 'getFindDestinationReqOptions - using destination user token to call find destination');
      auth = options.userToken;
    } else if (options && options.app && options.destinationKey && options.app.services && options.app.services[options.destinationKey] && options.app.services[options.destinationKey].token) {
      logRequestInfo(options, `getFindDestinationReqOptions - using destination key ${options.destinationKey} access token to call find destination`);
      auth = options.app.services[options.destinationKey].token.accessToken;
      shouldCache = true;
    } else if (options.destinationToken) {
      logRequestInfo(options, 'getFindDestinationReqOptions - using destination cc token to call find destination');
      auth = options.destinationToken;
    } else {
      return cb('Failed to determine destination token');
    }
    headers.Authorization = 'Bearer ' + auth;
    headers['x-correlationid'] = options.correlationId;
    if (options.preferLocal && options.userToken) {
      headers['x-user-token'] = options.userToken;
    }
    const requestOptions = {
      url: credentials.uri + '/destination-configuration/v1/destinations/' + destinationName,
      headers: headers,
    };
    shouldCache && (requestOptions.cache = {services: options.app.services, serviceName: options.destinationKey || DESTINATION});
    const authOptions = options.session && options.session.user && options.session.user.token && options.session.user.token.oauthOptions;
    if (authOptions && authOptions.certificate && authOptions.key && options.useIASMTLS) {
      requestOptions.cert = authOptions.certificate;
      requestOptions.key = authOptions.key;
      requestOptions.rejectUnauthorized = true;
    }

    return cb(null, requestOptions);
  });
}

function normalizeDestination(destination) {
  if (!destination) {
    return;
  }
  let keys = Object.keys(destination);
  let n = keys.length;
  let newobj = {};
  let key;
  while (n--) {
    key = keys[n];
    if (key === 'URL') {
      newobj[key.toLowerCase()] = destination[key];
    } else {
      let value = destination[key];
      key = key.replace('HTML5.', '');
      let newKey = key.substr(0, 1).toLowerCase() + key.substr(1);
      newobj[newKey] = value;
    }
  }
  return newobj;
}

function getDestinationServiceCredentials() {
  const credentials = vcapUtils.getServiceCredentials({tag: DESTINATION});
  if (credentials) {
    credentials.label = DESTINATION;
  }
  return credentials;
}

// Finds a destination by name on all levels and returns the first match
// Search priority is destination on instance level and after that fallback to the shared destinations on subaccount level.
function findDestination(destinationName, token, options, cb) {
  if (!destinationName) {
    return cb('Cannot find destination, destination name is missing');
  }

  if (destinationName.includes('$')) {
    return cb('destination contains invalid characters, check xs-app.json route.source attribute to make sure the regex is correct');
  }

  if (destinationName.includes('*')) {
    return cb('destination contains invalid characters, make sure the DESTINATION_HOST_PATTERN regex is correct');
  }

  let errorMessage;
  let destinationLookUpResult;
  getFindDestinationReqOptions(destinationName, token, options, function (error, requestOptions) {
    if (error) {
      return cb(error);
    }
    request.get(requestOptions, function onResponse(err, res) {
      if (err || !res || !res.statusCode) {
        return cb('Error while retrieving destination ' + destinationName + ' from destination service ' + (err && err.message) +
            ', token details: ' + (requestOptions && JSON.stringify(tokenUtils.getTokenInfo(requestOptions.headers.Authorization))));
      }
      if (res.statusCode !== 200 || !res.body) {
        errorMessage = 'Error while retrieving destination ' + destinationName + ' from destination service. HTTP status code: ' + res.statusCode +
            ', token details: ' + (requestOptions && JSON.stringify(tokenUtils.getTokenInfo(requestOptions.headers.Authorization)));
        return cb(errorMessage);
      }
      try {
        destinationLookUpResult = JSON.parse(res.body);
      } catch (err) {
        return cb(err);
      }
      cb(null, destinationLookUpResult);
    });
  });
}

function getDestinationToken(options, token, credentials, cb) {

  if (token) {
    options.userToken = token;
  }

  if (options.userToken && !options.preferLocal) {
    logRequestInfo(options, 'getDestinationToken - prefer user token in case not local destination requested');
    return cb(null, options);
  }

  let tenant = options.urlTenant || (options.session && options.session.user && options.session.user.tenant);

  if ((!tenant || options.preferLocal) && options.app) {
    logRequestInfo(options, 'getDestinationToken - If no tenant, take destination client credentials token (public access or not multi-tenant approuter or SaaS Approuter APIs)');
    if (options.app.services && options.app.services[DESTINATION]
        && options.app.services[DESTINATION].token
        && options.app.services[DESTINATION].token.tokenRefreshTimestamp - Date.now() > 0) {
      options.destinationToken = options.app.services[DESTINATION].token.accessToken;
      logRequestInfo(options, 'getDestinationToken - use cached destination token');
      return cb(null, options);
    } else {
      tokenUtils.loadClientCredentialsToken(options.app, options.correlationId, credentials, DESTINATION, (err) => {
        logRequestInfo(options, 'getDestinationToken - create new cc destination token');
        if (err) {
          let message = 'Could not fetch destination token ' + err;
          return cb(message);
        }
        options.destinationToken = options.app.services[DESTINATION].token.accessToken;
        return cb(err, options);
      });
    }
  } else if (tenant && options.app) {
    if (options.app.services[DESTINATION] && options.app.services[DESTINATION][tenant]
        && options.app.services[DESTINATION][tenant].token
        && options.app.services[DESTINATION][tenant].token.tokenRefreshTimestamp - Date.now() > 0) {
      options.destinationToken = options.app.services[DESTINATION][tenant].token.accessToken;
      logRequestInfo(options, 'getDestinationToken - get cached destination token by tenant');
      return cb(null, options);
    } else {
      logRequestInfo(options, 'getDestinationToken - create new destination token by tenant');
      tokenUtils.getClientCredentialsTokenByTenant(options.correlationId, tenant, credentials, (options.session && options.session.req && options.session.req.zoneInfo), (err, token) => {
        if (err) {
          let message = 'Could not get destination token from subscriber subaccount ' + tenant + ' ' + err;
          return cb(message);
        }
        if (!options.app.services[DESTINATION]) {
          options.app.services[DESTINATION] = {};
        }
        options.app.services[DESTINATION][tenant] = {token: token};
        options.destinationToken = token.accessToken;
        return cb(null, options);
      });
    }
  }
}

async function executeInChunks(promises, chunkSize, delay) {
  let results = [];
  for (let i = 0; i < promises.length; i += chunkSize) {
    const chunk = promises.slice(i, i + chunkSize);
    const chunkResults = await Promise.all(chunk).catch((err) => {
      logger.error(`Could not fetch destinations chunk, error ${err.message}, continue with next chunk`);
    });
    results = chunkResults && results.concat(chunkResults);

    if (i + chunkSize < promises.length) {
      // Add a delay before processing the next chunk
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
  return results;
}

function useIASToken(options, credentials) {
  const disableForwardCorporateIDPToken = process.env.DISABLE_FORWARD_CORPORATE_IDP_TOKEN;
  const token = options.session && options.session.user && options.session.user.token;
  const authenticationTypeIAS = token && token.authenticationType === 'ias';
  const iasTokensSupported = credentials && credentials['token-type'] && credentials['token-type'].indexOf('ias') > -1;
  // For now IAS token flow will only be used in case forward_corp_idp_token exists in login token and subaccount level destinations
  return !!(((token && authenticationTypeIAS && token.forwardCorpIdpToken) || (options.clientCredentialsFlow && options.iasSubscription)) && iasTokensSupported && !disableForwardCorporateIDPToken);
}