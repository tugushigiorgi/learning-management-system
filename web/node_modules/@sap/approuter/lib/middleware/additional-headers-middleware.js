'use strict';

const _     = require('lodash');
const request     = require('../utils/request-utils');
const passportUtils  = require('../passport/utils');
const stdTTL = process.env.FRAME_ANCESTORS_CSP_HEADER_CACHE_TIME || 300;
const checkPeriod           = stdTTL + 20;
const NodeCache           = require('node-cache');
const cspHeadersCache      = new NodeCache({stdTTL: stdTTL, checkperiod: checkPeriod});
// eslint-disable-next-line no-undef
const tracer = require('../utils/logger').getTracer(__filename);
const X_FRAME_OPTIONS = 'x-frame-options';
const CSP_HEADER_NAME = 'Content-Security-Policy';

module.exports = async function additionalHeaders(req, res, next) {
  let routerConfig = req.routerConfig;

  let additionalHeaders = routerConfig.additionalHeaders.slice();

  additionalHeaders = modifyAdditionalHeadersFromResponseHeaders(req,additionalHeaders);

  // replace x-approuter-instance header value with the instance id ( POD_NAME - kubernetes environment, CF_INSTANCE_INDEX - cf environment)
  // in k8s, you can configure the POD_NAME env variable to be the pod name from the metadata. You can see example here: https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#use-pod-fields-as-values-for-environment-variables
  const instanceID = process.env.POD_NAME || process.env.CF_INSTANCE_INDEX;
  additionalHeaders.forEach(function (header) {
    header['x-approuter-instance'] && instanceID && (header['x-approuter-instance'] = instanceID);
  });



  if (routerConfig.sendXFrameOptions) {
    let xFrameHeader = _.find(additionalHeaders, function searchXFrame(header) { return !!header[X_FRAME_OPTIONS]; });
    if (!xFrameHeader) {
      res.setHeader(X_FRAME_OPTIONS, 'SAMEORIGIN');
    }
  }
  additionalHeaders.forEach(function addAdditionalHeader(header) {
    try {
      _.forEach(header, function setHeader(value, name) {
        let currentValue = res.getHeader(name);
        if (currentValue === undefined) {
          res.setHeader(name, value);
        } else if (Array.isArray(currentValue)) {
          currentValue.push(value);
        } else { // string
          res.setHeader(name, [currentValue, value]);
        }
      });
    } catch (err) {
      return next(err);
    }
  });
  if (routerConfig.enableCSPheaders) {
    try {
      const btpTenantAPI = (routerConfig.iasConfig && routerConfig.iasConfig.options && routerConfig.iasConfig.options['btp-tenant-api']) ||
          (routerConfig.uaaConfig && routerConfig.uaaConfig.options && routerConfig.uaaConfig.options['apiurl']);
      await module.exports.getCSPFrameAncestorsFromSubaccount(req, res, btpTenantAPI);
    } catch (err) {
      return next(err);
    }
  }
  next();
};

function getLandscapeDomain(cfApiUrl) {
  let url = new URL(cfApiUrl);
  let parts = url.hostname.split('.');
  parts.shift(); // remove 'api'
  parts.shift(); // remove 'cf'
  return parts.join('.');
}

module.exports.getCSPFrameAncestorsFromSubaccount = async function getCSPFrameAncestorsFromSubaccount(req, res, btpTenantAPI) {
  const NOT_CONFIGURED = 'notConfigured';
  let subdomain = passportUtils.getTenantInfo(req).tenant;
  if (!subdomain) {
    return;
  }
  let apiURL;
  const securityPath = `/sap/rest/authorization/v2/securitySettings/public?subdomain=${subdomain}`;
  if (btpTenantAPI) {
    apiURL = `${btpTenantAPI}${securityPath}`;
  } else {
    const landscapeDomain = getLandscapeDomain(JSON.parse(process.env.VCAP_APPLICATION).cf_api);
    if (!landscapeDomain) {
      return;
    }
    apiURL = `https://api.authentication.${landscapeDomain}${securityPath}`;
  }
  // Check if cspHeaders are cached
  const cachedCSPHeaders = cspHeadersCache.get(subdomain);
  if (cachedCSPHeaders) {
    if (cachedCSPHeaders !== NOT_CONFIGURED) {
      res.setHeader(CSP_HEADER_NAME, cachedCSPHeaders);
    }
  } else {
    let result = await request.axiosRequest('get',{url: apiURL});
    if (result.error || result.response.statusCode !== 200){
      throw new Error('Failed to fetch allowed domains from xsuaa ' + result.error
            + (result.response && result.response.statusCode ? `response status ${result.response.statusCode}` : ''));
    }
    const resultBody = result.body && JSON.parse(result.body);
    if (resultBody && resultBody.iframeDomains) {
      const cspHeaders = `frame-ancestors ${resultBody.iframeDomains};`;
      cspHeadersCache.set(subdomain, cspHeaders);
      res.setHeader(CSP_HEADER_NAME, cspHeaders);
    } else {
      cspHeadersCache.set(subdomain, NOT_CONFIGURED);
    }
  }
};

module.exports.clearCache = function() {
  if (cspHeadersCache) {
    cspHeadersCache.flushAll();
  }
};

function modifyAdditionalHeadersFromResponseHeaders(req, additionalHeaders) {
  let foundIndex;

  if (!req.routerConfig.appConfig.responseHeaders){
    return additionalHeaders;
  }

  req.routerConfig.appConfig.responseHeaders.forEach(function (responseHeader) {
    foundIndex = -1;

    for (let i = 0; i < additionalHeaders.length; i++) {
      if (additionalHeaders[i].hasOwnProperty(responseHeader.name.toLowerCase())) {
        foundIndex = i;
        break;
      }
    }

    if (foundIndex > -1) {
      additionalHeaders[foundIndex] = {
        [responseHeader.name]: responseHeader.value
      };
      tracer.debug('found response header name %s in additional headers, so update response header value %s instead of previous value', responseHeader.name, responseHeader.value);
    }
    else {
      additionalHeaders.push({
        [responseHeader.name]: responseHeader.value
      });
    }

  });

  return additionalHeaders;
}
