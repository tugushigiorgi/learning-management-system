'use strict';

const basicAuthHeaderParser = require('basic-auth');
const cookie = require('cookie');
const cookieUtils = require('../utils/cookie-utils');
const oauthConfig = require('./../passport/oauth-configuration');
const passport = require('passport');
const headerUtil = require('../utils/header-util');
const pathUtil = require('../utils/path-util');
const sessionExt = require('../utils/session-ext');
const tokenUtils = require('../utils/token-utils');
const jwtDecode = require('jwt-decode');
const headerUtils = require('../utils/header-util');
const expiresAt = require('../passport/utils').getExpiresAt;
const logRequestInfo  = require('../utils/application-logs-utils').logRequestInfo;
const logoutProvider = require('../middleware/logout-provider');

module.exports = {
  isLoginRequired: function (req) {
    let isPublicPath = pathUtil.isPublicPath(req);
    let isUserLoggedIn = module.exports.isUserLoggedIn(req);
    logRequestInfo(req,`Is login required, isPublicPath ${isPublicPath}, isUserLoggedIn ${isUserLoggedIn}`);
    return !isPublicPath && !isUserLoggedIn;
  },

  isUserLoggedIn: function (req) {
    let token = req.session && req.session.user && req.session.user.token;
    if (!token || !token.accessToken || !token.expiryDate) {
      logRequestInfo(req,'User is not loggedIn, no user or token');
      return false;
    }
    return token.expiryDate > Date.now();
  },

  isExchangeTokenRequired: function (req) {
    const user = req.session && req.session.user;
    const token = user && user.token;
    const uniqueServiceName = req.destinationCredentials && req.destinationCredentials.uniqueServiceName;
    const sharedIASToken = req.destinationCredentials && req.destinationCredentials.ias && req.destinationCredentials.ias.sharedIASToken;

    if (!token || !token.expiryDate || token.expiryDate < Date.now() || !uniqueServiceName) {
      return false;
    }
    const isExchangeTokenRequired = !user.businessServices || !user.businessServices[uniqueServiceName]
        || !user.businessServices[uniqueServiceName].accessToken || user.businessServices[uniqueServiceName].expireDate < Date.now()
        || !!(sharedIASToken && user.businessServices[uniqueServiceName].jti !== token.jti);

    logRequestInfo(req,`Exchange token required = ${isExchangeTokenRequired} for service  ${uniqueServiceName}`);
    return isExchangeTokenRequired;
  },

  exchangeToken: async function (req, cb) {
    const loginToken    = req.session.user.token.accessToken;
    const loginIdToken  = req.session.user.token.idToken;
    const correlationId = headerUtils.getCorrelationId(req);

    if (req.destinationCredentials.ias && req.zoneInfo) {
      // If shared IAS token, the login token is also used by the destination business service
      // If IASDependencyName configured, login token is exchanged by another IAS token using the
      // IAS dependency name, to be used by the target business service.
      if (req.destinationCredentials.ias.sharedIASToken){
        try {
          updateSession(req, loginToken, null);
        } catch (err){
          return cb('Failed to update session for sharedIASToken: ' + err.message);
        }
        return cb(null);
      } else if (req.destinationCredentials.ias.IASDependencyName){
        const credentials = req.session.user.token.oauthOptions;
        credentials.tokenEndPoint = req.zoneInfo.tokenEndpoint;
        credentials.apptid = req.zoneInfo.apptid;
        let iasExchangedToken;
        try {
          const token = await tokenUtils.getApp2AppToken(loginIdToken, credentials, req.destinationCredentials.ias.IASDependencyName, correlationId);
          iasExchangedToken = token.access_token;
        } catch (err){
          return cb('Failed to exchange login token by an IAS token using IAS dependency name: ' + req.destinationCredentials.ias.IASDependencyName + ' error: ' + err.message);
        }
        if (req.destinationCredentials.uaa) {
          tokenUtils.exchangeToken(loginToken, correlationId, req.destinationCredentials.uaa, (err, xsuaaExchangedToken) => {
            if (err) {
              return cb('Failed to exchange login token by an XSUAA token in IAS context' + err.message);
            }
            try {
              updateSession(req, iasExchangedToken, xsuaaExchangedToken);
            } catch (err){
              return cb('Failed to update session for iasExchangedToken and xsuaaExchangedToken: ' + err.message);
            }
            return cb(null);
          });
        } else {
          try {
            updateSession(req, iasExchangedToken, null);
          } catch (err){
            return cb('Failed to update session for iasExchangedToken: ' + err.message);
          }
          return cb(null);
        }
      } else {
        return cb('Invalid IAS credentials configuration');
      }
    } else {
      tokenUtils.exchangeToken(loginToken, correlationId, req.destinationCredentials.uaa, (err, xsuaaExchangedToken) => {
        if (err) {
          return cb('Failed to exchange login token by an XSUAA token ' + err.message);
        }
        try {
          updateSession(req, null, xsuaaExchangedToken);
        } catch (err){
          return cb('Failed to update session for xsuaaExchangedToken: ' + err.message);
        }
        return cb(null);
      });
    }
  },

  getAuthenticator: function (req, res, cb) {
    if (pathUtil.isBasicAuthProtectedPath(req)) {
      return getBasicAuthAuthenticator(req, cb);
    }

    getXSUAAOauthAuthenticator(req, function (err, authenticator) {
      if (err) {
        return cb(err);
      }

      if (process.env.PRESERVE_FRAGMENT === 'false') {
        let redirectCookieName = cookieUtils.getRedirectLocationCookieName();
        let cookies = (req.headers.cookie && cookie.parse(req.headers.cookie)) || {};
        let redirectCookie = cookies[redirectCookieName];
        if (!redirectCookie) {
          let locationAfterLogin = cookieUtils.serialize(req, redirectCookieName, req.url, {path: '/', httpOnly: true});
          cookieUtils.setCookie(res, locationAfterLogin);
        }
      }

      if ((process.env.DELETE_STALE_COOKIES === 'true' ||
          cookieUtils.shouldPartitionCookie(req) ||
          logoutProvider.getBackChannelLogoutEndpoint(req) ||
          pathUtil.isStateProtectionEnabled(req)) &&
          cookieUtils.isBrowserRequest(req)) {
        const staleCookiesFound = cookieUtils.addStaleSessionCookies(req, res);
        if (staleCookiesFound) {
          res.writeHead(302, {'Location': req.url});
          res.end();
          return;
        }
      }

      if (cookieUtils.shouldPartitionCookie(req) || pathUtil.isStateProtectionEnabled(req) || logoutProvider.getBackChannelLogoutEndpoint(req)) {
        cookieUtils.addSessionCookie(req, res);
      }
      res.setHeader('Cache-Control', headerUtil.NOCACHE_HEADER_VALUE);
      cb(null, authenticator);
    });
  }
};

function getXSUAAOauthAuthenticator(req, cb) {
  oauthConfig.getXSUAAOauthStrategy(req, function (err, oauthStrategy) {
    if (err) {
      return cb(err);
    }
    cb(null, createAuthenticator(oauthStrategy));
  });
}

function getBasicAuthAuthenticator(req, cb) {
  let basicAuthHeader = basicAuthHeaderParser(req);
  if (!basicAuthHeader) {
    return cb(401);
  }

  let credentials = {
    username: basicAuthHeader.name,
    password: basicAuthHeader.pass
  };

  oauthConfig.getBasicOauthStrategy(req, credentials, function (err, oauthStrategy) {
    if (err) {
      return cb(err);
    }
    cb(null, createAuthenticator(oauthStrategy));
  });
}

function createAuthenticator(oauthStrategy) {
  passport.use(oauthStrategy);
  return passport.authenticate(oauthStrategy.name,oauthConfig.SESSION_OPTIONS);
}

function updateSession(req, iasExchangedToken, xsuaaExchangedToken) {
  let exchangedTokenDecoded = iasExchangedToken ? jwtDecode(iasExchangedToken) : jwtDecode(xsuaaExchangedToken);
  let xsuaaExchangedTokenDecoded = xsuaaExchangedToken && iasExchangedToken ? jwtDecode(xsuaaExchangedToken) : exchangedTokenDecoded;
  let expireDate = expiresAt(exchangedTokenDecoded.exp - exchangedTokenDecoded.iat).getTime();
  let accessToken = iasExchangedToken ? iasExchangedToken : xsuaaExchangedToken;

  sessionExt.update(req.session, function (session) {
    if (!session.user.businessServices) {
      session.user.businessServices = {};
    }
    session.user.businessServices[req.destinationCredentials.uniqueServiceName] = {
      accessToken: accessToken,
      expireDate: expireDate,
      jti: exchangedTokenDecoded.jti,
      scopes: xsuaaExchangedTokenDecoded ? xsuaaExchangedTokenDecoded.granted_scopes || xsuaaExchangedTokenDecoded.scope : null
    };
  });
}