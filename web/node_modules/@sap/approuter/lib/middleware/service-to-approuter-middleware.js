'use strict';
const jwtDecode = require('jwt-decode');
const passportUtils = require('../passport/utils');
const pathUtil = require('../utils/path-util');
const headerUtils = require('../utils/header-util');
const logger = require('../utils/logger');
const vcapUtils = require('../utils/vcap-utils');
const basicAuth = require('basic-auth');
const tokenUtils = require('../utils/token-utils');
const cookieUtils = require('../utils/cookie-utils');
const crypto = require('crypto');

module.exports = async function (req, res, next) {
  let auth = req.headers && req.headers['x-approuter-authorization'];
  if (!auth) {
    return next();
  }
  const tracer = req.loggingContext.getTracer(__filename);
  tracer.debug('Incoming request contains x-approuter-authorization header');

  if (req.routerConfig && pathUtil.isPublicPath(req)) {
    tracer.debug('Request to public route with url %s contains x-approuter-authorization header ', req.url);
  }

  if (req.headers['x-approuter-authorization'].startsWith('Basic')){
    const ownCredentials = vcapUtils.getServiceCredentials({label: 'xsuaa'});
    if (ownCredentials) {
      ownCredentials.label = 'xsuaa';
      if (process.env.XSUAA_PRIVATE_KEY){
        ownCredentials.key = process.env.XSUAA_PRIVATE_KEY;
      }
    }
    const creds = basicAuth({headers: {authorization: req.headers['x-approuter-authorization']}});
    if (!creds){
      return writeAuditLog(req, null , `Invalid x-approuter-authorization header for request url ${req.url}`, 401, null, ownCredentials, next);
    }
    try {
      const tenant = req.tenant || getTenant(req,null,ownCredentials);
      const tokenResponse = await tokenUtils.getPasswordUserToken(tenant, creds, ownCredentials, headerUtils.getCorrelationId(req));
      if (req.requiredRoleCollection && (!tokenResponse.tokenDecoded.roleCollections ||
          tokenResponse.tokenDecoded.roleCollections.indexOf(req.requiredRoleCollection) < 0)){
        const tokenKey = tenant + creds.name + creds.pass;
        tokenUtils.deleteTokenCache(tokenKey);
        return writeAuditLog(req, creds.name , `Setting log level failed for request url ${req.url} because the required role collection ${req.requiredRoleCollection} is missing`, 403, creds.name, ownCredentials, next);
      }
      req.headers['x-approuter-authorization'] = `Bearer ${tokenResponse.accessToken}`;
      return handleSession(req,tokenResponse.tokenDecoded, tokenResponse.accessToken,tracer,{credentials:ownCredentials},res, next);
    } catch (err){
      return writeAuditLog(req, creds.name , `${err.message} - Token validation failed for request url ${req.url}`, 401, creds.name, ownCredentials, next);
    }
  } else {
    let tokenDecoded;
    try {
      tokenDecoded = jwtDecode(auth);
    } catch (err) {
      let error = new Error('Failed to decode x-approuter-authorization token ' + err);
      error.status = 400;
      return next(error);
    }

    const authArr = auth.split(' ');
    const type = authArr[0];
    const tokenValue = authArr[1];
    let service = getCredentialsAndSecurityType(tokenDecoded);
    if (!service.credentials) {
      return next('No Security service instance bound for service type ' + service.type);
    }
    if (type.toLowerCase() !== 'bearer') {
      return writeAuditLog(req, tokenValue, 'x-approuter-authorization header is not a Bearer token', 400, tokenDecoded, service.credentials, next);
    }
    const config = {
      credentials: service.credentials,
      correlationId: headerUtils.getCorrelationId(req)
    };
    try {
      await tokenUtils.checkSecurityContext(tokenValue,config);
      return handleSession(req, tokenDecoded, tokenValue, tracer, service, res, next);
    } catch (err) {
      writeAuditLog(req, tokenValue, `${err.message} - Token validation failed for request url ${req.url}`, 401, tokenDecoded, service.credentials, next);
    }
  }
};

function writeAuditLog(req, token, errorMessage, errorStatus, tokenDecoded, credentials, next) {
  let auditlogCredentials;
  const tracer = req.loggingContext.getTracer(__filename);
  tracer.error && tracer.error(errorMessage);
  auditlogCredentials = vcapUtils.getServiceCredentials({tag: 'auditlog'});

  let IP = (auditlogCredentials) ? req.headers['x-forwarded-host'] : '******';
  const authorization = (auditlogCredentials) ? token : '******';
  const sourceOfRoute = req.internalUrl ? req.internalUrl.route.source : req.url;
  const message = errorMessage + '- Source of route: ' + sourceOfRoute + ', IP: ' + IP + ', x-approuter-authorization: ' + authorization;

  const loggingData = {};
  loggingData.user = 'Service to Approuter request';
  loggingData.tenantid = getTenant(req, tokenDecoded, credentials);
  logger.writeToAuditLog(req, loggingData, message, function (err) {
    if (err) {
      req && req.logger && req.logger.error('Error occurred when writing to audit log. Error: %s', err.message);
    }
    let error = new Error(errorMessage);
    error.status = errorStatus;
    return next(error);
  });
}

function getTenant(req, tokenDecoded, credentials) {
  let tenant = passportUtils.getUrlTenant(req) || credentials.identityzone;
  if (req.headers['x-subscriber-tenant']) {
    tenant = req.headers['x-subscriber-tenant'];
  } else {
    if (tokenDecoded && tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn) {
      tenant = tokenDecoded.ext_attr.zdn;
    } else if (tokenDecoded && tokenDecoded['iss']) {
      tenant = getIasTenant(tokenDecoded);
    }
  }
  return tenant;
}

function getIasTenant(tokenDecoded) {
  let temp = tokenDecoded['iss'].split('.')[0].split('/');
  return temp[temp.length - 1];
}

function getCredentialsAndSecurityType(tokenDecoded) {
  let service = {};
  if (tokenDecoded && tokenDecoded.ext_attr) {
    service.credentials = vcapUtils.getServiceCredentials({tag: 'xsuaa'});
    if (process.env.XSUAA_PRIVATE_KEY){
      service.credentials.key = process.env.XSUAA_PRIVATE_KEY;
    }
    service.type = 'XSUAA';
  } else {
    service.credentials = vcapUtils.getServiceCredentials({label: 'identity'});
    if (process.env.IAS_PRIVATE_KEY){
      service.credentials.key = process.env.IAS_PRIVATE_KEY;
    }
    service.type = 'IAS';
  }
  return service;
}

async function handleSession(req, tokenDecoded, tokenValue, tracer, service, res, next) {
  const externalSessionStore = req && req.app && req.app.get('externalSessionStore');

  let externalSessionExpiry = tokenDecoded.exp;
  let externalSessionId = tokenDecoded.jti;
  let externalSessionIdSig;
  const providedExternalSessionId = req.headers['x-approuter-ext-session-id'];
  if (externalSessionStore && providedExternalSessionId) {
    externalSessionId = providedExternalSessionId;
    externalSessionIdSig = req.headers['x-approuter-ext-session-id-sig'];
    if (!externalSessionIdSig) {
      return next('x-approuter-ext-session-id-sig is missing');
    }
    if (!req.headers['x-approuter-ext-session-expiry']){
      return next('x-approuter-ext-session-expiry is missing');
    }
    externalSessionExpiry = parseInt(req.headers['x-approuter-ext-session-expiry']);
    if (Number.isNaN(externalSessionExpiry)) {
      return next('x-approuter-ext-session-expiry should be a number');
    }
    if (externalSessionExpiry <= Math.floor(Date.now() / 1000)) {
      return next('x-approuter-ext-session-expiry should be a timestamp in the future');
    }
    delete req.headers['x-approuter-ext-session-id'];
    delete req.headers['x-approuter-ext-session-expiry'];
    delete req.headers['x-approuter-ext-session-id-sig'];
  }

  let externalSession = null;
  if (externalSessionStore) {
    externalSession =  await externalSessionStore.getExternalSession(externalSessionId, req);
  }

  let externalSessionUpdate = false;
  if (externalSession) {
    req.session = externalSession;
    if (req.session.user.token.accessToken !== tokenValue){
      req.session.user = passportUtils.getUserProperties(getTokenContext(tokenValue, tokenDecoded, service.credentials, service.type));
      externalSessionUpdate = true;
    }
    if (req.session.externalSessionExpiration !== externalSessionExpiry) {
      req.session.externalSessionExpiration = externalSessionExpiry;
      externalSessionUpdate = true;
    }
  } else {
    req.session = {
      externalSessionId: externalSessionStore && externalSessionId,
      externalSessionExpiration: externalSessionStore && externalSessionExpiry,
      jwtRefreshStarted: true,
      user: passportUtils.getUserProperties(getTokenContext(tokenValue, tokenDecoded, service.credentials, service.type)),
      req: req,
      reload: function (cb) {
        cb();
      },
      save: function () {
      },
      touch: function () {
      }
    };
    externalSessionUpdate = true;
    if (process.env.SVC2AR_EXTERNAL_SESSION_COOKIE_ENABLED === 'true') {
      res && providedExternalSessionId && cookieUtils.addSessionCookie(req, res);
    }
  }
  if (externalSessionStore && externalSessionUpdate) {
    if (providedExternalSessionId) {
      try {
        if (!verifyExtSessionIdSignature(externalSessionId, externalSessionIdSig)) {
          delete req.session;
          return writeAuditLog(req, tokenValue, `external session id signature verification failed for request url ${req.url}, x-approuter-ext-session-id ${providedExternalSessionId}, x-approuter-ext-session-signature: ${externalSessionIdSig}`, 401, tokenDecoded, service.credentials, next);
        }
      } catch (e) {
        delete req.session;
        return next(e);
      }
    }
    await externalSessionStore.updateExternalSession(req.session);
  }
  tracer.info('Session created successfully');
  return next();
}

function getTokenContext(tokenValue, tokenDecoded, credentials, authenticationType) {
  const tokenContext = {
    expiresIn: Date.now() + 600000,
    scope: tokenDecoded.scope,
    oauthOptions: credentials
  };
  if (authenticationType === 'IAS'){
    tokenContext.accessToken = tokenContext.idToken  = tokenValue;
    tokenContext.oauthOptions.authenticationType = 'ias';
    tokenDecoded.ias_iss && (tokenContext.oauthOptions.url = tokenDecoded.ias_iss);
  }
  else {
    tokenContext.accessToken  = tokenValue;
    tokenContext.oauthOptions.authenticationType = 'xsuaa';
  }
  return tokenContext;
}

function sign(val, secret) {
  return crypto
    .createHmac('sha256', secret)
    .update(val)
    .digest('base64')
    .replace(/\=+$/, '');
}

function verifySignature(value, signature, secret) {
  const expectedSig = sign(value, secret);
  const expectedSigBuffer = Buffer.from(expectedSig);
  const inputSigBuffer = Buffer.from(signature);
  return expectedSigBuffer.length === inputSigBuffer.length && crypto.timingSafeEqual(expectedSigBuffer, inputSigBuffer);
}

function verifyExtSessionIdSignature(extSessionId, extSessionIdSig) {
  const secrets = [
    process.env.SVC2AR_EXTERNAL_SESSION_ID_SECRET,
    process.env.SVC2AR_EXTERNAL_SESSION_ID_SECRET_ALT
  ].filter(secret => typeof secret === 'string' && secret.length > 0);
  if (secrets.length === 0) {
    throw new Error('SVC2AR_EXTERNAL_SESSION_ID_SECRET and/or SVC2AR_EXTERNAL_SESSION_ID_SECRET_ALT should be a non-empty string');
  }
  for (const secret of secrets) {
    if (verifySignature(extSessionId, extSessionIdSig, secret)) {
      return true;
    }
  }
  return false;
}
