'use strict';

const urlUtils = require('../utils/url-utils');
const NodeCache = require('node-cache');
const http = require('http');
let circuitBreakerCache = null;
const headerUtil = require('../utils/header-util');

module.exports.circuitBreakerMiddleware = function circuitBreakerMiddleware(req, res, next) {
  if (!circuitBreakerCache) {
    return next();
  }
  const invalidAppCacheKey = getCacheKey(req);
  const circuitOpen = circuitBreakerCache.get(invalidAppCacheKey);
  if (circuitOpen) {
    const logger = req.loggingContext && req.loggingContext.getLogger('/get-circuit-breaker');
    logger && logger.info(`Circuit open for ${invalidAppCacheKey}, returning cached response`);
    return sendResponse(res,circuitOpen.status, {'x-circuit-breaker-open':'true', 'Cache-Control': headerUtil.NOCACHE_HEADER_VALUE}, circuitOpen.err.message);
  }
  next();
};

module.exports.setCircuitBreaker = function setCircuitBreaker(req, err, statusCode) {
  const circuitBreakerConf = getCircuitBreakerConf(req);
  const statusConf = circuitBreakerConf && circuitBreakerConf[statusCode];
  if (!statusConf) {
    return;
  }
  initializeCircuitBreakerCache(circuitBreakerConf);
  const invalidAppCacheKey = getCacheKey(req);
  const logger = req.loggingContext && req.loggingContext.getLogger('/set-circuit-breaker');
  logger && logger.info(`Circuit opened for ${invalidAppCacheKey} and status ${statusCode}`);
  try {
    circuitBreakerCache.set(invalidAppCacheKey, {err:err, status:statusCode}, statusConf.ttl);
  } catch (e) {
    const message = e.errorcode === 'ECACHEFULL' ? `Circuit breaker cache is full, cannot set more keys, maxKeys = ${circuitBreakerConf.maxKeys}` : e.message;
    logger && logger.error(message);
  }
};

module.exports.getCircuitBreakerCache = function getCircuitBreakerCache() {
  return circuitBreakerCache;
};

function getCacheKey(req) {
  return `${urlUtils.getAppRouterHost(req)}_${req.url}_${req.method}`;
}

function sendResponse(res, status, headers, err) {
  if (res.headersSent) {
    return;
  }
  res.writeHead(status, headers);
  const message = err.message || http.STATUS_CODES[status];
  res.end(message);
}

function initializeCircuitBreakerCache(circuitBreakerConf) {
  if (!circuitBreakerCache) {
    const maxKeys = circuitBreakerConf.maxKeys || 20000;
    const checkperiod = circuitBreakerConf.checkperiod || 30;
    circuitBreakerCache = new NodeCache({maxKeys: maxKeys, checkperiod: checkperiod});
  }
}

function getCircuitBreakerConf(req) {
  const routerConfig = req.app.get('mainRouterConfig');
  return routerConfig && routerConfig.circuitBreakerConf;
}