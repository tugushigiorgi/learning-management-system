'use strict';
const tokenUtils = require('../utils/token-utils');
const headerUtils = require('../utils/header-util');
const destinationUtils = require('../utils/destination-utils');
require('../utils/uaa-utils');
const xsenv = require('@sap/xsenv');
const CONNECTIVITY = 'connectivity';
const IDENTITY = 'identity';
const vcapUtils = require('../utils/vcap-utils');
const {getTenantInfo} = require('../passport/utils');
let   isConnectivityBound = null;
const { promisify } = require('util');
const loadClientCredentialsTokenProm = promisify(tokenUtils.loadClientCredentialsToken);
const CLIENT_CREDENTIALS = 'client_credentials';

module.exports = async function renewToken(req, res, next) {
  const businessServiceData = getBusinessServiceData(req);
  if (!businessServiceData) {
    return next();
  }

  const logger  = req.loggingContext && req.loggingContext.getLogger('/ClientCredentialsTokenMiddleware');
  const correlationId = headerUtils.getCorrelationId(req);

  try {
    await loadClientCredentialsToken(req,businessServiceData, correlationId);
  } catch (err) {
    const message = `Error while loading client credentials token: ${err.message}`;
    return next(message);
  }

  try {
    await exchangeClientCredentialsTokenByTenant(req, businessServiceData, correlationId);
  } catch (err) {
    // In case the service is multitenant (except connectivity), but it was not subscribed this creating a token from subscriber might fail. In such case provider token is used.
    const message = `Could not get ${businessServiceData.service} token from subscriber subaccount ${businessServiceData.tenant}, fetching from provider subaccount. Error: ${err.message}`;
    logger && logger.info(message);
    if (businessServiceData.service === CONNECTIVITY) {
      return next(message);
    }
  }
  return next();
};

function getServiceByName(requestedServiceName) {
  let services = xsenv.readServices();
  if (services) {
    for (let serviceName in services) {
      let service = services[serviceName];
      if (service.label === requestedServiceName && service.credentials) {
        const serviceCredentials = service.credentials.uaa ? service.credentials.uaa : service.credentials;
        serviceCredentials.instanceId = service['instance_guid'];
        return serviceCredentials;
      }
    }
  }
  return null;
}

async function loadClientCredentialsToken(req,businessServiceData, correlationId) {
  if (businessServiceData.loadTokenRequired) {
    await loadClientCredentialsTokenProm(req.app,correlationId, businessServiceData.credentials, businessServiceData.service);
  }
  if (businessServiceData.iasLoadTokenRequired) {
    const token =  await tokenUtils.getIASClientCredentialsToken(businessServiceData.iasCredentials, businessServiceData.credentials.instanceId, correlationId);
    setTokenCache(req, businessServiceData.service, 'iasToken', token);
  }
}

async function exchangeClientCredentialsTokenByTenant(req, businessServiceData, correlationId) {
  if (businessServiceData.iasTokenExchangeRequired) {
    // eslint-disable-next-line camelcase
    businessServiceData.iasCredentials.app_tid = businessServiceData.apptid;
    businessServiceData.iasCredentials.tokenURL = req.zoneInfo.tokenEndpoint;
    const token =  await tokenUtils.getIASClientCredentialsToken(businessServiceData.iasCredentials, businessServiceData.credentials.instanceId, correlationId);
    setTokenCache(req, businessServiceData.service, 'iasToken', token, businessServiceData.tenant);
  }
  if (businessServiceData.tokenExchangeRequired) {
    const token =  await tokenUtils.getClientCredentialsTokenByTenant(correlationId, businessServiceData.tenant, businessServiceData.credentials, req.zoneInfo);
    token && setTokenCache(req, businessServiceData.service, 'token', token, businessServiceData.tenant);
  }
}

function getBusinessServiceData(req) {
  const route = req.internalUrl && req.internalUrl.route;
  if (!route || (!route.service && !route.destination)) {
    return null;
  }
  const tenant = req.tenant = getTenantInfo(req).tenant;
  let serviceName;
  if (route.service) {
    serviceName = route.service === 'html5-apps-repo-rt' ? 'html5-apps-repo' : route.service;
  } else if (route.destination) {
    isConnectivityBound = isConnectivityBound === null ? vcapUtils.getServiceCredentials({ label: CONNECTIVITY }) !== null : isConnectivityBound;
    if (!isConnectivityBound) {
      return null;
    }
    serviceName = isConnectivityBound && CONNECTIVITY;
  }
  const serviceCredentials = getServiceByName(serviceName);
  if (!serviceCredentials) {
    return null;
  }
  const serviceNameInt = serviceName === 'html5-apps-repo' ? 'html5-apps-repo-rt' : serviceName;
  const service = req && req.app && req.app.services && req.app.services[serviceNameInt];
  const existingToken = service && service.token;
  const iasExistingToken = service && service.iasToken;
  const tenantToken = service && service[tenant] && service[tenant].token;
  const iasTenantToken = service && service[tenant] && service[tenant].iasToken;
  const isMultitenant = serviceName === CONNECTIVITY || (serviceCredentials.saasregistryenabled || serviceCredentials.saasregistryappname) && serviceCredentials['grant_type'] === CLIENT_CREDENTIALS;
  const iasCredentials = vcapUtils.getServiceCredentials({ label: IDENTITY });
  iasCredentials && (iasCredentials.label = CONNECTIVITY);
  const options = {
    clientCredentialsFlow: !!iasCredentials,
    iasSubscription: req.zoneInfo && req.zoneInfo.authenticationType === 'ias'
  };
  const useIASToken = destinationUtils.useIASToken(options, serviceCredentials);
  return {
    tenant: tenant,
    credentials: serviceCredentials,
    service: serviceName,
    loadTokenRequired: (serviceName === CONNECTIVITY || serviceCredentials['grant_type'] === CLIENT_CREDENTIALS) && (!existingToken || isTokenExpired(existingToken)),
    iasLoadTokenRequired: serviceName === CONNECTIVITY && useIASToken && (!iasExistingToken || isTokenExpired(iasExistingToken)),
    tokenExchangeRequired: serviceName !== 'html5-apps-repo' && isMultitenant && (!tenantToken || isTokenExpired(tenantToken)),
    iasTokenExchangeRequired: serviceName === CONNECTIVITY && useIASToken && isMultitenant && (!iasTenantToken || isTokenExpired(iasTenantToken)),
    iasCredentials: iasCredentials,
    apptid : req.zoneInfo && req.zoneInfo.apptid
  };
}

function isTokenExpired(token) {
  return token.tokenRefreshTimestamp - Date.now() <= 0;
}

function setTokenCache(req, service, tokenType, token, tenant) {
  token.tokenRefreshTimestamp = Date.now() + (token.expires_in - 60) * 1000; // Refresh token 1 minute before it expires
  if (!req.app.services[service]) {
    req.app.services[service] = {};
  }
  if (tenant && !req.app.services[service][tenant]) {
    req.app.services[service][tenant] = {};
  }
  tenant ? req.app.services[service][tenant][tokenType] = token : req.app.services[service][tokenType] = token;
}