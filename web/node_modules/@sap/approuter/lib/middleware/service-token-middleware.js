'use strict';

const serviceTokenHandler = require('./service-token-handler');
const jwtDecode = require('jwt-decode');
const expiresAt = require('../passport/utils').getExpiresAt;
const businessServiceUtils = require('../utils/business-service-utils');
const sessionExt = require('../utils/session-ext');

// if it is saas approuter flow use uniqueServiceName (<bs name>!<destination guid>), else use req.internalUrl.route.service (<bs name>)
const getServiceTag = (req) => req.destinationCredentials && req.destinationCredentials.uniqueServiceName && req.internalUrl.route.credentials && req.internalUrl.route.credentials.uniqueServiceName ? req.internalUrl.route.credentials.uniqueServiceName : req.internalUrl.route.service;

module.exports = function (req, res, next) {
  if (!req.internalUrl || !req.internalUrl.route) {
    return next();
  }

  const serviceTag = getServiceTag(req);
  if (!serviceTag){
    return next();
  }

  attachHeadersFromCredentials(req, serviceTag);

  if (!isTokenExchangeRequired(req)) {
    return next();
  }

  shouldAskBusinessToken(req, serviceTag, function(err, askForToken){
    if (err) {
      return next(err);
    }
    if (!askForToken) {
      return next();
    }
    serviceTokenHandler.replaceUserToken(req, null, null, function(err, token) {
      if (process.env.NODE_ENV === 'development') {
        req.session.user = {};
      }
      if (err) { return next(err); }
      let tokenDecoded = token.access_token ? token : jwtDecode(token);
      let accessToken  = token.access_token ? token.access_token : token;
      sessionExt.update(req.session, function(// eslint-disable-next-line
        session) {
        if (!session.user.businessServices) {
          session.user.businessServices = {};
        }
        session.user.businessServices[serviceTag] = {accessToken:  accessToken, expireDate:  expiresAt(tokenDecoded.exp - tokenDecoded.iat).getTime()};
      },next);
    });
  });
};

function isTokenExchangeRequired(req){
  if (req.internalUrl.route.service && req.internalUrl.route.credentials && businessServiceUtils.getGrantType(req.internalUrl.route.credentials) === 'user_token'){
    return true;
  }
  return false;
}

function shouldAskBusinessToken(req, serviceTag, cb){
  if (process.env.NODE_ENV === 'development') {
    if (req.session) {
      return cb(null, true);
    } else {
      return cb(null, false);
    }
  }

  if (!req.session || !req.session.user){
    return cb(new Error('Route with service needs oauth authentication'));
  }
  if (!req.session.user.businessServices || !req.session.user.businessServices[serviceTag] || req.session.user.businessServices[serviceTag].expireDate < Date.now()) { // no token for current business service or token expired - ask for token
    return cb(null, true);
  }

  return cb(null, false);
}

function attachHeadersFromCredentials(req, serviceTag) {
  const existingHeaders = Object.keys(req.headers || []);
  const businessServiceCredentials = businessServiceUtils.getCredentials(serviceTag, false, req);

  for (const key in businessServiceCredentials) {
    if (key.toLowerCase().startsWith('url.headers')) {
      const headerKey = key.split('.')[2];
      if (headerKey && !existingHeaders.includes(headerKey)) {
        req.headers[headerKey] = businessServiceCredentials[key];
      }
    }
  }
}
