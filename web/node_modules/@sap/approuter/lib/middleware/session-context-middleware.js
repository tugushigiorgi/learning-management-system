'use strict';

const jwtDecode = require('jwt-decode');
const cookie = require('cookie-signature');
const {validateSessionContextInput} = require('../configuration/validators');

module.exports = (req, res, next) => {

  const body = req.body;
  if (req.method !== 'POST') {
    return next(getBadInputError(405, 'Invalid method ' + req.method + '. Only POST method is allowed.'));
  }
  if (!('sap-ugw' in req.headers)) {
    return next(getBadInputError(400, 'Invalid request. Missing sap-ugw header.'));
  }
  if (!req.headers['sap-ugw'].split(',').map(s => s.trim()).includes('origin=ugw')) {
    return next(getBadInputError(400, 'The sap-ugw header does not have the value: origin=ugw.'));
  }

  try {
    validateSessionContextInput(body);
  } catch (err) {
    return next(getBadInputError(400, err.message));
  }
  let sessionContextDataRequired = body.sessionContextDataRequired;
  let sessionsList = body.sessionsList;
  try {
    const secret = req.app.get('sessionCookieKey');
    const store = req.app.approuter.getSessionStore();
    const sessions = sessionsList.map(externalSessionId => {
      const sessionId = cookie.unsign(externalSessionId.slice(2), secret);
      if (!sessionId) {
        return null;
      }
      return new Promise((resolve, reject) => {
        store.getSessionWithoutResetTimeout(sessionId, (session) => {
          if (session && session.user && session.user.token) {
            store.getSessionTimeout(session.id, function (err, sessionTimeout) {
              if (err) {
                reject(err);
              }
              let expiryDateTimestamp = session.user.token.expiryDate;
              let sessionTimeoutTimestamp = Date.now() + sessionTimeout * 60 * 1000; // Convert sessionTimeout from minutes to milliseconds
              let calculatedTimeout = Math.min(expiryDateTimestamp, sessionTimeoutTimestamp);
              let responseData = {
                sessionId: externalSessionId,
                sessionTimeout: calculatedTimeout,
              };
              if (sessionContextDataRequired) {
                responseData.claims = jwtDecode(session.user.token.accessToken);
                responseData.isStickySession = !(req.routerConfig && req.routerConfig.extSessionMgt);
              }
              resolve(responseData);
            });
          }
          resolve(null);
        });
      });
    }, {});
      // resolve all promises in sessions
    Promise.all(sessions).then(results => {
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify(results.filter(item => item !== null)));
    }).catch(err => {
      return next(err);
    });
  } catch (err) {
    return next(err);
  }
};

function getBadInputError(status, errorString) {
  let error = new Error(errorString);
  error.status = status;
  return error;
}