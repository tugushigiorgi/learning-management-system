'use strict';

const jwtDecode             = require('jwt-decode');
const requestUtils          = require('../utils/request-utils');
const CURRENT_USER_ENDPOINT = 'currentUser';
const ATTRIBUTES_ENDPOINT   = 'attributes';
const USER_API_SERVICE      = 'sap-approuter-userapi';

const ignoreClaims = [
  'aud', 'nonce', 'remoteEntityId', 'zone_uuid', 'sub', 'given_name', 'family_name', 'email', 'first_name', 'last_name',
  'azp', 'mail', 'app_tid', 'iss', 'sid', 'ias_iss', 'scim_id', 'cnf', 'jti', 'exp', 'iat', 'nbf', 'auth_time', 'acr',
  'amr',  'azp', 'at_hash', 'c_hash', 'sub_jwk', 'ias_apis', 'scim_id'
];

module.exports = async function getUserDetails(req, res, next) {
  let userDetails;
  let response;

  if (req.internalUrl && req.internalUrl.route && req.internalUrl.route.service
    && req.internalUrl.route.service === USER_API_SERVICE
    && req.session && req.session.user && req.session.user.token
    && req.session.user.token.accessToken) {
    let endPoint = null;
    if (req.url.includes(CURRENT_USER_ENDPOINT)) {
      endPoint = CURRENT_USER_ENDPOINT;
    } else if (req.url.includes(ATTRIBUTES_ENDPOINT)) {
      endPoint = ATTRIBUTES_ENDPOINT;
    } else {
      return next('Invalid user API endpoint provided');
    }
    let decodedToken = null;
    try {
      decodedToken = jwtDecode(req.session.user.token.accessToken);
    } catch (err) {
      return next('Failed to decode login token ' + err);
    }

    const bsScopes = req.session && req.session.user && req.destinationCredentials && req.destinationCredentials.uniqueServiceName
      && req.session.user.businessServices && req.session.user.businessServices[req.destinationCredentials.uniqueServiceName]
      && req.session.user.businessServices[req.destinationCredentials.uniqueServiceName].scopes;
    const oauthScopes = req.session && req.session.user && req.session.user.scopes;

    userDetails = {
      firstname: decodedToken.given_name,
      lastname: decodedToken.family_name,
      email: decodedToken.email || decodedToken.name,
      name: decodedToken.ext_attr ? (decodedToken.user_name || decodedToken.email) : decodedToken.sub,
      scopes: bsScopes || oauthScopes
    };
    if (endPoint === CURRENT_USER_ENDPOINT) {
      userDetails.displayName = userDetails.firstname && userDetails.lastname ?
        // eslint-disable-next-line max-len
        userDetails.firstname + ' ' + userDetails.lastname + ' (' + userDetails.name + ')'
        : userDetails.name;
      response = JSON.stringify(userDetails, undefined, 2);
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Cache-Control', 'no-cache, no-store');
      return res.end(response);
    }
    else if (endPoint === ATTRIBUTES_ENDPOINT) {
      try {
        let allProperties = await addCustomProperties(req, userDetails,decodedToken);
        response = JSON.stringify(allProperties, undefined, 2);
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Cache-Control', 'no-cache, no-store');
        return res.end(response);
      }
      catch (err) {
        next(err);
      }
    }
  } else {
    return next();
  }
};

async function addCustomProperties(req, userDetails,decodedToken) {
  let responseJSON;
  let userAttributes;
  const authenticationType = req.session.user.token && req.session.user.token.oauthOptions && req.session.user.token.oauthOptions.authenticationType;

  if (authenticationType === 'xsuaa'){
    const serviceOptions = getServiceOptions(req);
    const { error, response, body } = await requestUtils.axiosRequest('get',serviceOptions);
    if (error || (response && response.statusCode !== 200)){
      req.logger && req.logger.info('Failed to fetch user info by access token ' + (error ? error : response && response.statusCode));
      return userDetails;
    }
    try {
      responseJSON = JSON.parse(body);
      userAttributes = responseJSON && responseJSON['user_attributes'];
    } catch (err) {
      throw new Error(`Parsing user info ${body} failed  ${err}`);
    }
  } else if (authenticationType === 'ias'){
    userAttributes = decodedToken;
  }

  if (userAttributes) {
    ignoreClaims.forEach(claim => delete userAttributes[claim]);
    return Object.assign({}, userDetails, userAttributes);
  }
  return userDetails;
}

function getServiceOptions(req) {
  const accessToken = req.session.user.token && req.session.user.token.accessToken;
  const oauthOptions = req.session.user.token && req.session.user.token.oauthOptions;
  oauthOptions.url = !oauthOptions.url.endsWith('/') ? oauthOptions.url + '/' : oauthOptions.url;
  return {
    url: oauthOptions.url + 'userinfo',
    headers: {
      Authorization: 'Bearer ' + accessToken
    }
  };
}