'use strict';

const URI = require('urijs');
const encodeUrl = require('encodeurl');
const http = require('http');
const urlUtils = require('../utils/url-utils');
const headerUtils = require('../utils/header-util');
const loggerUtils = require('../utils/logger');
const backendRequestOptions = require('../backend-request/options');
const passportUtils = require('../passport/utils');
const dynamicRoutingUtils = require('../utils/dynamic-routing-utils');
const businessServiceUtils = require('../utils/business-service-utils');
const serviceTokenHandler = require('./service-token-handler');
const agents = require('../backend-request/agents');
const destinationTokenHandler = require('./destination-token-handler');
const vcapUtils = require('../utils/vcap-utils');
const pathUtil = require('../utils/path-util');
const tokenUtils = require('../utils/token-utils');
const cookieUtils = require('../utils/cookie-utils');
const logger = loggerUtils.getLogger('/Middleware');
const tracer = loggerUtils.getTracer(__filename);

module.exports = {
  sessionTimeoutLogout: function (session, app) {
    if (session && session.user) {
      logout(app, null, session);
    }
  },

  isLogoutRequest: function (req) {
    const coreUrl = dynamicRoutingUtils.getCoreUrl(req);
    const authenticationType = pathUtil.pathAuthenticationType(req);
    const parsedUrl = URI.parse(coreUrl);
    const logoutConfig = req.routerConfig && req.routerConfig.appConfig && req.routerConfig.appConfig.logout;
    const logoutEndpoint = logoutConfig && logoutConfig.logoutEndpoint;
    const backChannelLogoutEndpoint = module.exports.getBackChannelLogoutEndpoint(req);
    req.isBackChannelLogout = req.method === 'POST' && parsedUrl.path === backChannelLogoutEndpoint && authenticationType === 'ias';
    return !!((((req.method === 'GET' || req.method === 'POST') && logoutEndpoint && parsedUrl.path === logoutEndpoint)) ||
        req.isBackChannelLogout);
  },

  getBackChannelLogoutEndpoint: function (req) {
    return req && req.routerConfig && req.routerConfig.appConfig
        && req.routerConfig.appConfig.logout
        && req.routerConfig.appConfig.logout.backChannelLogoutEndpoint;
  },

  centralLogout: function (req, res) {
    if (req.isBackChannelLogout) {
      return module.exports.handleBackChannelLogout(req, res);
    }
    logout(req.app, req, Object.assign({id: req.session.id}, req.session));
    let token = req && req.session && req.session.user && req.session.user.token;
    req.idToken = token && token.idToken ? token.idToken.valueOf() : null;
    req.authenticationType = token && token.authenticationType;
    req.session.destroy();

    cookieUtils.setSessionCookieForDeletion(req, res);

    const queryParams = req && req.url && URI.parse(req.url).query;
    if ((token && token.singleUseToken) || (queryParams &&
        (queryParams.includes('skip-redirect=true') || queryParams.includes('skip-redirect')))) {
      return res.end();
    }
    module.exports.triggerUAARedirect(req, res, function (err) {
      if (err) {
        throw err;
      }
    });
  },

  handleBackChannelLogout: function (req, res) {
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });
    req.on('end', async () => {
      try {
        const tokenValue = body.split('=')[1];
        const sid = await this.validateLogoutToken(tokenValue);
        logger.info(`Logging out from IAS sid ${sid}`);
        const memoryStore = req && req.app.get('memoryStore');
        const sessionDestroyed = await memoryStore.destroyIASSession(sid);
        sessionDestroyed ? logger.info(`Approuter session for IAS sid ${sid} has been destroyed`)
          : logger.info(`Approuter session for IAS sid ${sid} not found`);
        res.statusCode = 200;
        return res.end();
      } catch (err) {
        const msg = `Error validating logout token: ${err.message}`;
        res.statusCode = 400;
        return res.end(msg);
      }
    });
  },

  validateLogoutToken: async function (token) {
    const credentials = vcapUtils.getServiceCredentials({
      label: 'identity'
    });
    if (process.env.IAS_PRIVATE_KEY) {
      credentials.key = process.env.IAS_PRIVATE_KEY;
    }
    const ctx = await tokenUtils.checkSecurityContext(token, {credentials});
    if (!ctx.token) {
      throw new Error('Token missing in security context');
    }
    const payload = ctx.token.getPayload();

    if (payload.nonce) {
      throw new Error('Nonce is not allowed in logout token');
    }

    const logoutEvent = payload.events && payload.events['http://schemas.openid.net/event/backchannel-logout'];
    if (!logoutEvent) {
      throw new Error('Event claim is missing in logout token');
    }
    const sid = payload.sid;
    if (!sid) {
      throw new Error('Session ID is missing in logout token');
    }
    return sid;
  },


  callBackendLogoutPaths: function (req, routerConfig, session) {
    const appConfigDestinations = routerConfig.appConfig.destinations || {};
    const dynamicDestinations = (session && session.user && session.user.logout) ? session.user.logout.destinations : {};
    const destinations = Object.assign(appConfigDestinations, dynamicDestinations);
    const accessToken = session && session.user && session.user.token && session.user.token.accessToken;

    for (let destinationName in destinations) {
      const destinationOptions = destinations[destinationName];
      if (destinationOptions.logoutPath) {
        let destination = routerConfig.destinations[destinationName];
        if (destination) {
          // Add indication that this is logout flow. This is needed in order to avoid sending the wrong token to the destination.
          // There is a case when req.internalUrl.service is set to html5-apps-repo-rt service.
          // In this case the accessToken will be overriden by the service's token (html5-apps-repo-rt service) in authorization header (see addOauthHeader() in headers.js)
          // and as a result the wrong token will be sent to the destination
          destination.isLogout = true;
          module.exports.handleRequest(req, accessToken, destination, destinationOptions, session);
        } else {
          destinationTokenHandler.retrieveDestination({
            destinationName: destinationName,
            session: session,
            correlationId: headerUtils.getCorrelationId(req)
          },
          function (err, result) {
            if (err || !result) {
              logger.error(err, 'Error retrieving destination ', destinationName);
              return;
            }
            destination = result.destination;
            module.exports.handleRequest(req, result.authToken, destination, destinationOptions, session);
          });
        }
      }
    }
  },

  callServiceLogoutPaths: function (req, session) {

    if (!session || !session.user || !session.user.logout || !session.user.logout.services) {
      return;
    }
    const logoutServices = session.user.logout.services;
    for (let serviceTag in logoutServices) {
      const serviceLogoutOptions = logoutServices[serviceTag];
      const serviceCredentials = businessServiceUtils.getCredentials(serviceTag, false, {session: session});
      if (!serviceCredentials) {
        continue;
      }
      const serviceDestination = businessServiceUtils.getEndPoint(serviceCredentials, serviceLogoutOptions.endpoint);
      if (serviceLogoutOptions.logoutPath) {
        const serviceLogoutUri = urlUtils.join(serviceDestination.url, serviceLogoutOptions.logoutPath);
        const parsedUrl = urlUtils.parse(serviceLogoutUri);
        const method = serviceLogoutOptions.logoutMethod || 'POST';
        serviceTokenHandler.replaceUserToken(req, session, serviceTag, function (err, token) {
          if (err) {
            logger.error(err, 'Error receiving service token for service ', serviceTag);
            return;
          }
          const request = module.exports.getServiceLogoutRequest({
            method: method,
            parsedUrl: parsedUrl,
            token: token,
            approuterHost: serviceLogoutOptions.approuterHost,
            req: req,
            destination: serviceDestination,
            session: session
          });
          sendRequest(request, serviceLogoutOptions, serviceLogoutUri);
        });
      }
    }
  },

  handleRequest: function (req, token, destination, destinationOptions, session) {
    const logoutUri = urlUtils.join(destination.url, destinationOptions.logoutPath);
    const request = backendRequestOptions.getLogoutRequest(req, token, destination, destinationOptions, session);
    sendRequest(request, destination, logoutUri);
  },

  triggerUAARedirect: function (req, res, cb) {
    resolveLogoutRedirectUrl(req, function (err, redirectUrl) {
      if (!err) {
        if (req.method === 'POST') {
          res.statusCode = 200;
          res.setHeader('Content-Type', 'text/html');
          res.setHeader('Content-Security-Policy', 'script-src \'self\' \'unsafe-inline\'; frame-ancestors *');
          res.setHeader('Cache-Control', headerUtils.NOCACHE_HEADER_VALUE);
          res.end(encodeUrl(redirectUrl));
        } else {
          res.writeHead(302, {Location: encodeUrl(redirectUrl)});
          res.end();
        }
      }
      cb(err);
    });
  },

  getServiceLogoutRequest: function (options) {
    const headers = {};
    headers.authorization = 'Bearer ' + options.token;
    if (options.approuterHost) {
      headers['x-approuter-host'] = options.approuterHost;
    }
    backendRequestOptions.getBackendCookies(options.req, options.session, headers, options.destination);
    const opts = {
      method: options.method,
      protocol: options.parsedUrl.protocol,
      hostname: options.parsedUrl.hostname,
      port: options.parsedUrl.port,
      path: options.parsedUrl.path,
      agent: agents.get(options.parsedUrl.protocol),
      headers: headers
    };

    return http.request.bind(undefined, opts);
  },
  isLogoutCsrfProtectionEnabled: function (req) {
    return (req.routerConfig.appConfig.logout.csrfProtection === true ||
        (req.routerConfig.appConfig.logout.csrfProtection === undefined && req.routerConfig.appConfig.logout.logoutMethod === 'POST'));
  },
  isReqMethodMatchesLogoutMethod: function (req) {
    let logoutMethod = req.routerConfig.appConfig.logout.logoutMethod;
    if (logoutMethod) {
      if (req.method !== logoutMethod){
        return `request method (${req.method}) does not match logout configuration logoutMethod (${logoutMethod})`;
      }
    } else if (req.method === 'POST') {
      return 'logoutMethod property required in order to use POST request';
    }
  }
};

function logout(app, req, session) {
  module.exports.callBackendLogoutPaths(req, app.get('mainRouterConfig'), session);
  module.exports.callServiceLogoutPaths(req, session);
  app.approuter.emit('logout', session);
}

function sendRequest(request, destination, logoutUri) {

  const clientReq = request();
  if (destination.timeout) {
    clientReq.setTimeout(destination.timeout);
  }
  clientReq.on('timeout', function () {
    clientReq.abort();
    logger.error('Request to %s failed with a timeout', logoutUri);
  });
  clientReq.on('error', function (err) {
    logger.error(err, 'Error in request to %s', logoutUri);
  });
  clientReq.on('response', function (resp) {
    if (destination.timeout) {
      resp.setTimeout(destination.timeout);
    }
    resp.on('timeout', function () {
      clientReq.abort();
      logger.error('Request to %s failed with a timeout', logoutUri);
    });
    resp.on('error', function (err) {
      logger.error(err, 'Error in response from %s', logoutUri);
    });
    let body = '';
    resp.on('data', function (chunk) {
      body += chunk;
    });
    resp.on('end', function () {
      if (resp.statusCode !== 200 && resp.statusCode !== 202) {
        logger.error('Status %d received for request to %s, body: %s', resp.statusCode, logoutUri, body);
      }
      tracer.info('Status %d received for request to %s, body: %s', resp.statusCode, logoutUri, body);
    });
  });
  clientReq.end();
}

function resolveLogoutRedirectUrl(req, cb) {
  // Currently redirect from UAA to application is possible only with port-based routing
  const logout = req.routerConfig.appConfig.logout;
  const isIas = req.authenticationType === 'ias';
  let logoutPage = logout && logout.logoutPage;
  passportUtils.getAuthConfig(req, req.authenticationType, function (err, authConfig) {
    if (err) {
      return cb(err);
    }
    const endSessionEndpoint = req.zoneInfo && (req.zoneInfo.authenticationType === req.authenticationType) && req.zoneInfo.endSessionEndpoint;
    const path = req.authenticationType === 'ias' ? '/oauth2/logout' : '/logout.do';
    const redirectUrl = endSessionEndpoint || urlUtils.join(authConfig.url, path);
    if (!logoutPage) {
      return cb(null, redirectUrl);
    }


    // concat query parameters for logout page, if exists
    const queryParams = URI.parse(req.url).query;
    if (queryParams) {
      logoutPage = logoutPage + '?' + queryParams;
    }

    const uri = URI.parse(logoutPage);
    const redirectQuery = isIas ? '?post_logout_redirect_uri=' : '?redirect=';
    const additionalQueryParams = isIas && req.idToken ? '&id_token_hint=' + req.idToken : '&client_id=' + authConfig.clientid;

    if (uri.protocol && uri.hostname) {
      return cb(null, redirectUrl + redirectQuery + encodeURIComponent(logoutPage) + additionalQueryParams);
    }
    const skipGetAppKey = !!(process.env.SKIP_APP_KEY_WITH_X_FORWARD_PATH && process.env.SKIP_APP_KEY_WITH_X_FORWARD_PATH === 'true' && req.headers['x-forwarded-path']);
    if (!skipGetAppKey) {
      const fullUrl = dynamicRoutingUtils.getFullUrl(req, logoutPage);
      if (/^\/(.*$)?$/.test(fullUrl)) {
        logoutPage = fullUrl;
      }
    }
    let logoutPageUrl;
    const appRouterUrl = urlUtils.buildAppRouterUrl(req);
    if (isIas) {
      logoutPageUrl = encodeURIComponent(urlUtils.join(appRouterUrl, logoutPage));
      cb(null, redirectUrl + redirectQuery + logoutPageUrl + additionalQueryParams);
    } else {
      if (process.env.DISABLE_XSUAA_ENCODING === 'true') { // don't encode for backward compatibility
        cb(null, redirectUrl + redirectQuery + urlUtils.join(appRouterUrl, logoutPage) + additionalQueryParams);
      } else {
        logoutPageUrl = encodeURIComponent(urlUtils.join(appRouterUrl, logoutPage));
        cb(null, redirectUrl + redirectQuery + logoutPageUrl + additionalQueryParams);
      }
    }
  });
}