'use strict';

const _ = require('lodash');
const url = require('url');
const headerUtil = require('../utils/header-util');
const pathUtil = require('../utils/path-util');
const cookieUtils = require('../utils/cookie-utils');
const businessServiceUtils = require('../utils/business-service-utils');
const dynamicRoutingUtils = require('../utils/dynamic-routing-utils');
const passportUtils = require('../passport/utils');

const HTML5_APPS_REPO_NAME = process.env.HTML5_APPS_REPO_NAME || 'html5-apps-repo';

let HEADERS_TO_REMOVE = ['connection',
  'keep-alive',
  'public',
  'proxy-authenticate',
  'transfer-encoding',
  'upgrade',
  'x-approuter-authorization',
  'x-custom-host',
  ':authority'  ,
  ':method',
  ':path',
  ':scheme',
  'sec-websocket-key'];

exports.getHeaders = function (req, accessToken, destination) {
  const logger = req && req.loggingContext && req.loggingContext.getLogger && req.loggingContext.getLogger('/headers.js');
  let headers;
  let route = req && req.internalUrl ? req.internalUrl.route : null;
  let tokens = {
    // In flow of Logout:
    // env destination => we get JWT token in tokens.accessToken as a String
    // destination service destination => we get destination auth token in tokens.accessToken as an Object
    accessToken: accessToken
  };
  if (req) {
    // 1. Access token returned from destination or bs service logout
    tokens.accessToken = tokens.accessToken ||
        // 2. Access token obtained from local xsuaa in saas-approuter flow
        (req.session && req.session.user && req.destinationCredentials && req.destinationCredentials.uniqueServiceName
            && req.session.user.businessServices && req.session.user.businessServices[req.destinationCredentials.uniqueServiceName]
            && req.session.user.businessServices[req.destinationCredentials.uniqueServiceName].accessToken) ||
        // 3. Access token obtained from the statically bound xsuaa instance
        (req.session && req.session.user && req.session.user.token && req.session.user.token.accessToken);
    destination = destination || req.internalUrl.destination;

    tokens.service2ApprouterToken = req.headers['x-approuter-authorization'];

    let servicePreserveHostHeader = req.internalUrl && req.internalUrl.route && req.internalUrl.route.service &&
        req.internalUrl.route.credentials && req.internalUrl.route.credentials.preserve_host_header;

    if ((destination && destination.preserveHostHeader) || servicePreserveHostHeader) {
      headers = _.omit(req.headers, HEADERS_TO_REMOVE);
    } else {
      headers = _.omit(req.headers, HEADERS_TO_REMOVE.concat(['host']));
    }
    if (destination && destination['sap-client']) {
      headers['sap-client'] = destination['sap-client'];
    }
    if (destination && destination.proxyType === 'OnPremise' && req.app.services && req.app.services['connectivity']) {
      // If destination was fetch with IAS token, also connectivity service should be called with IAS token
      if (destination.iasTokenFlow){
        logger && logger.info('Using IAS token for connectivity service');
        tokens['connectivity'] = req.tenant && req.app.services['connectivity'][req.tenant] && req.app.services['connectivity'][req.tenant].iasToken ?
          req.app.services['connectivity'][req.tenant].iasToken : req.app.services['connectivity'].iasToken;
      } else {
        logger && logger.info('Using XSUAA token for connectivity service');
        tokens['connectivity'] = req.tenant && req.app.services['connectivity'][req.tenant] && req.app.services['connectivity'][req.tenant].token ?
          req.app.services['connectivity'][req.tenant].token : req.app.services['connectivity'].token;
      }
    }

    if (destination && req.session && req.session.user && req.session.user.destinationUserExchangeToken){
      tokens['userToken'] = req.session.user.destinationUserExchangeToken.token;
    }

    if (destination && req.session && req.session.user && req.session.user.destinationKey && req.session.user.destinationKey.destinationUserExchangeToken){
      tokens['userToken'] = req.session.user.destinationKey.destinationUserExchangeToken.token;
    }

    addXForwardingHeaders(headers, req, destination);
    removeSecurityHeaders(headers, req);
    if (req.headers['x-approuter-authorization'] && headers.cookie) {
      const backendName = cookieUtils.getBackendName(req);
      headers.cookie = cookieUtils.decryptCookies(headers.cookie, backendName, logger);
    }
    headerUtil.updateSapPassport(headers);
    const destinationKey = req.destinationKey && destination && destination.name ? req.destinationKey + '-' + destination.name : (destination && destination.name);
    if (destinationKey && req.session && req.session.user && req.session.user.destinations
        && req.session.user.destinations[destinationKey]
        && req.session.user.destinations[destinationKey].authToken){
      tokens['authToken'] = req.session.user.destinations[destinationKey].authToken;
    } else if (req.internalUrl && req.internalUrl.route
        && req.internalUrl.route.destination && req.internalUrl.route.authToken){
      tokens['authToken'] = req.internalUrl.route.authToken;
    }
    // technical services
    if (route && route.service && req.app && req.app.services && req.app.services[route.service]){
      let tenant = req && passportUtils.getUrlTenant(req);
      tokens[route.service] = (tenant && req.app.services[route.service][tenant] && req.app.services[route.service][tenant].token) ?
        req.app.services[route.service][tenant].token : req.app.services[route.service].token;
    }
    if (route && route.service === 'html5-apps-repo-rt') {
      const appKey = dynamicRoutingUtils.getApplicationKey(req);
      const businessServiceName = appKey && ((appKey.bsKey && appKey.bsKey.appPrefix) || appKey.appPrefix);
      if (businessServiceName) {
        addAppHostIdHeader(businessServiceName, headers, req);
      }
    }
    if (route && route.credentials && businessServiceUtils.forwardIasToken(route.credentials) && isIasLoginToken(req)){
      tokens.forwardIasToken = req.session.user.token.accessToken;
    }
  }
  const logInfo = req && passportUtils.getTenantInfo(req).logInfo;
  logInfo && !headers.tenantid && (headers.tenantid = logInfo);

  return addOauthHeader(headers || {}, tokens, route, destination, logger);
};

function removeSecurityHeaders(headers, req) {
  if (!pathUtil.isPublicPath(req)) {
    delete headers['authorization'];
    if (pathUtil.isCsrfProtectionEnabled(req)) {
      delete headers['x-csrf-token'];
    }
  }
}

function addOauthHeader(headers, tokens, route, destination, logger) {
  // Destination flow
  if ((route && route.destination) || (destination && destination.isLogout)) {
    // On premise destination flow - cloud connector
    if (destination.proxyType && destination.proxyType === 'OnPremise') {
      if ((tokens.accessToken && !tokens.service2ApprouterToken) ||
          (tokens.accessToken && tokens.service2ApprouterToken)) {
        if ((!process.env.SEND_CONNECTIVITY_AUTHENTICATION && destination.authentication === 'PrincipalPropagation') ||
            (process.env.SEND_CONNECTIVITY_AUTHENTICATION && destination.authentication !== 'NoAuthentication')){
          // In case of corporate IDP token propagation destination service returns the corporate IDP token in the http_header with key SAP-Connectivity-Authentication.
          // If SAP-Connectivity-Authentication returned from destination it will be sent as SAP-Connectivity-Authentication header, else destination user token or login token
          const sapConnectivityAuthentication = tokens.authToken && tokens.authToken.http_header
          && tokens.authToken.http_header.key === 'SAP-Connectivity-Authentication' ? tokens.authToken.http_header.value : null;
          sapConnectivityAuthentication && logger && (logger.info('Using SAP-Connectivity-Authentication returned from destination service'));
          headers['SAP-Connectivity-Authentication'] = sapConnectivityAuthentication || ('Bearer ' + (tokens.userToken || tokens.accessToken));
        }
      }
      headers['Proxy-Authorization'] = 'Bearer ' +  (tokens['connectivity'].accessToken || tokens['connectivity'].access_token);
      if (destination.cloudConnectorLocationId) {
        headers['SAP-Connectivity-SCC-Location_ID'] = destination.cloudConnectorLocationId;
      }
      logger && (logger.info('Sending Proxy-Authorization header for OnPremise destination flow'));
    } else { // Cloud destination flow
      if (tokens && tokens.accessToken && destination.forwardAuthToken) {
        headers.authorization = 'Bearer ' + tokens.accessToken;
      }
      logger && (logger.info('Forwarding access token for Cloud destination flow'));
    }
    // Common for on premise and cloud destination flows
    // Use tokens provided from destination service
    if (tokens['authToken'] && tokens['authToken']['http_header'].value) {
      headers[tokens['authToken']['http_header'].key] = tokens['authToken']['http_header'].value;
    }
    logger && (logger.info('Sending auth token returned from destination service'));
  } else if (route && route.service) {// Service flow
    if (businessServiceUtils.getGrantType(route.credentials) === 'client_credentials') {// html5 apps repo flow
      headers.authorization = tokens[route.service].tokenType + ' ' + tokens[route.service].accessToken;
      logger && (logger.info(`Sending client credentials token for service ${route.service}`));
    } else {
      headers.authorization = 'Bearer ' + tokens.accessToken;
      if (tokens.forwardIasToken){
        logger && (logger.info(`Sending ias token for service ${route.service}`));
        headers['x-ias-token'] = tokens.forwardIasToken;
      }
      logger && (logger.info(`Sending user token for service ${route.service}`));
    }
  } else {// WS or Logout
    if (tokens && tokens.accessToken) {
      //  In case of Logout:
      // env destination => we send JWT token in tokens.accessToken as a String
      // destination service destination => we send destination auth token in tokens.accessToken as an Object
      let tokenType = tokens.accessToken.type ? tokens.accessToken.type : 'Bearer';
      let tokenValue = tokens.accessToken.value ? tokens.accessToken.value : tokens.accessToken;
      headers.authorization = tokenType + ' ' + tokenValue;
    }
  }
  return headers;
}

function addXForwardingHeaders(headers, req, destination) {
  if (destination && destination.setXForwardedHeaders === false){
    const xForwardedHeadersKeys = Object.keys(headers).filter(key => key.startsWith('x-forwarded'));
    xForwardedHeadersKeys.forEach(headerKey =>  delete headers[headerKey]);
    return;
  }
  if (req.headers.host) {
    headers['x-forwarded-host'] = req.headers['x-forwarded-host'] || req.headers.host;
  }
  if (!headers['x-forwarded-proto'] && req.protocol) {
    headers['x-forwarded-proto'] = req.headers['x-forwarded-proto'] || req.protocol;
  }
  if (!headers['x-forwarded-for']) {
    headers['x-forwarded-for'] = req.connection.remoteAddress;
  }
  if (!headers['x-forwarded-path']) {
    headers['x-forwarded-path'] = req.headers['x-forwarded-path'] || url.parse(req.url).pathname;
  }
}

function addAppHostIdHeader(businessServiceName, headers, req) {
  let businessServiceCredentials = businessServiceUtils.getCredentials(businessServiceName, true, req);
  if (businessServiceCredentials && businessServiceCredentials[HTML5_APPS_REPO_NAME] && businessServiceCredentials[HTML5_APPS_REPO_NAME]['app_host_id']) {
    headers['x-app-host-id'] = businessServiceCredentials[HTML5_APPS_REPO_NAME]['app_host_id'];
  }
}

function isIasLoginToken(req){
  return req && req.session && req.session.user && req.session.user.token.authenticationType === 'ias';
}
