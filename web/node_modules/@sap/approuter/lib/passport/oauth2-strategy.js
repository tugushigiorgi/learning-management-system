'use strict';

const assert = require('assert');
const Strategy = require('passport').Strategy;
const util = require('util');
const OAuth2 = require('./oauth2').OAuth2;
const passportUtils = require('./utils');
const state = require('./state');
const cookieUtils = require('../utils/cookie-utils');
const headerUtil = require('../utils/header-util');
const querystring = require('querystring');
const tokenUtils = require('../utils/token-utils');
const pathUtil = require('../utils/path-util');
const loginCallbackProvider = require('../middleware/login-callback-provider');
const jwtDecode = require('jwt-decode');
const cookie = require('cookie');
const drUtils = require('../utils/dynamic-routing-utils');
const _ = require('lodash');

module.exports = OAuth2Strategy;

function OAuth2Strategy(options, verify) {
  this.name = 'oauth2';
  assert(verify, 'OAuth2Strategy requires a "verify" callback');
  assert(options.callbackURL, 'OAuth2Strategy requires "callbackURL" option');
  assert(options.authorizationURL, 'OAuth2Strategy requires "authorizationURL" option');

  this.verify = verify;
  this._callbackURL = options.callbackURL;
  this._authorizationURL = options.authorizationURL;
  this._oauth2 = new OAuth2(options);

  Strategy.call(this, options, verify);
}

util.inherits(OAuth2Strategy, Strategy);

OAuth2Strategy.prototype.authenticate = async function (req, options) {
  options = options || {};

  if (req.query && req.query.error) {
    const error = getAuthorizationError(req.query.error_description, req.query.error);
    return (req.query.error === 'access_denied') ? this.fail(error) : this.error(error);
  }
  const loggingContext = req.loggingContext;
  const logger = loggingContext.getLogger('/Auth/OAuth2');
  const callbackURL = options.callbackURL || this._callbackURL;
  const authorizationURL = options.authorizationURL || this._authorizationURL;
  const redirectCookieName = cookieUtils.getRedirectLocationCookieName();
  const fragmentCookieName = cookieUtils.getFragmentCookieName();
  let originalUrl;
  if (!req.query || !req.query.code || (req.query.code && !loginCallbackProvider.isLoginCallback(req))) {
    let location;
    try {
      location = await this._oauth2.getCodeAuthorizationUrl(req, authorizationURL, callbackURL);
    }
    catch (error) {
      logger.error(error.message);
      return this.error(error);
    }

    logger.info('query does not exist for request url %s', req.url);

    if (process.env.PRESERVE_FRAGMENT !== 'false') {
      logger.info('sending page with client-side redirect to %s', location);
      logger.info('x-forwarded-path header: %s', req.headers['x-forwarded-path']);

      const path = req.headers['x-forwarded-path'];
      const query = req.headers['x-forwarded-query'];

      let fullForwardedPath = path;
      if (path && query) {
        fullForwardedPath += path.includes('?') ? `&${query}` : `?${query}`;
      }

      originalUrl = fullForwardedPath || req.url;
      cookieUtils.signCookie(req, originalUrl, function (err, signature) {
        if (err) {
          req.res.statusCode = 500;
          req.res.statusMessage = 'Malformed server configuration';
          req.res.end();
          return;
        }
        let openScriptTag = '<script>';
        let cspHeaderValue = 'script-src \'self\' \'unsafe-inline\'; frame-ancestors *';
        if (process.env.INCLUDE_NONCE_ATTR){
          const nonce = headerUtil.generateNonce();
          openScriptTag = `<script nonce="${nonce}">`;
          cspHeaderValue = `script-src 'self' 'nonce-${nonce}'; frame-ancestors *`;
        }
        req.res.statusCode = 200;
        req.res.setHeader('Content-Type', 'text/html');
        req.res.setHeader('Content-Security-Policy', cspHeaderValue);
        req.res.setHeader('Cache-Control', headerUtil.NOCACHE_HEADER_VALUE);
        let fragmentCookie = fragmentCookieName + '="+encodeURIComponent(location.hash)+";path=/";';
        let redirectCookie = redirectCookieName + (process.env.INCLUDE_HOST_IN_REDIRECT ?
          '="+encodeURIComponent(location.href.split(\'#\')[0].substring(location.href.split(\'#\')[0].indexOf(location.host) + location.host.length))+";path=/";'
          : '="+encodeURIComponent(location.href.split(\'#\')[0].split(location.host)[1])+";path=/";');
        let signatureCookie = signature + ';path=/";';
        req.res.end(
          '<html>' +
            '<head>' +
            '<link rel="shortcut icon" href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" />' +
            openScriptTag +
            'document.cookie="' + cookieUtils.addAttributes(fragmentCookie, req) +
            'document.cookie="' + cookieUtils.addAttributes(redirectCookie, req) +
            'document.cookie="signature=' + cookieUtils.addAttributes(signatureCookie, req) +
            'location="' + location + '"</script>' +
            '</head>' +
            '</html>'
        );
        delete req.res;
      });
      return;
    } else {
      logger.info('sending redirect to %s', location);
      return this.redirect(location);
    }
  }

  const cookies = cookie.parse(req.headers.cookie || '');
  if (
    cookieUtils.isBrowserRequest(req) &&
    pathUtil.isStateProtectionEnabled(req) &&
    (await isStateProtectionEnabledForCBurl(req, cookies, logger))
  ) {
    const sessionCookieName = req.app && req.app.get('cookieName');
    const stateCookie = cookies[sessionCookieName];

    if (!req.query || !req.query.state) {
      logger.error('State parameter is missing in the response from the authorization service');
      returnResponseStatus(req, 400, 'State parameter is missing in the response from the authorization service');
      return;
    }
    const stateFound = state.getCacheStateValue(req.query.state);
    if (!stateFound) {
      logger.error(`State parameter ${req.query.state} not found in cache`);
      returnResponseStatus(req, 401, `State parameter ${req.query.state} is missing or invalid`);
      return;
    }
    if (stateCookie !== req.query.state) {
      logger.error(`State parameter ${req.query.state} not match session cookie value`);
      returnResponseStatus(req, 401, `State parameter ${req.query.state} is missing or invalid`);
      return;
    }
  }
  const that = this;

  if (process.env.PRESERVE_FRAGMENT !== 'false') {
    let cookies = req.headers.cookie && req.headers.cookie.split(/\s*;\s*/).reduce((acc, cur) => {
      const [key, val] = cur.split('=');
      if (!acc[key]) {
        acc[key] = [];
      }
      acc[key].push(val);
      return acc;
    }, Object.create(null));

    if (!cookies) {
      const maskedUrl = req.url.replace(/code=([^&]*)/, (_, code) => {
        // Replace the middle part of the auth code with ***
        const maskedCode = code.length > 10 ? `${code.slice(0, 3)}***${code.slice(-3)}` : '***';
        return `code=${maskedCode}`;
      });
      logger.error('Cookies are missing for request url %s', maskedUrl);
      returnResponseStatus(req, 400, 'Cookies are missing');
      return;
    }

    const redirectCookie = querystring.unescape(cookies[redirectCookieName] && cookies[redirectCookieName][0]);
    const signatureCookie = cookies['signature'];

    cookieUtils.verifyCookie(req, redirectCookie, signatureCookie, function (err) {
      if (err) {
        returnResponseStatus(req, 400, 'Signature does not match');
        return;
      }
      delete req.res;
      getAccessToken(req, that, callbackURL, loggingContext);
    });
  } else {
    getAccessToken(req, that, callbackURL, loggingContext);
  }
};

function returnResponseStatus(req, code, message) {
  req.res.statusCode = code;
  req.res.statusMessage = message;
  req.res.end();
  delete req.res;
}

function getAuthorizationError(message, code) {
  const error = new Error(message);
  switch (code) {
  case 'access_denied':
    error.status = 403;
    break;
  case 'server_error':
    error.status = 502;
    break;
  case 'temporarily_unavailable':
    error.status = 503;
    break;
  }
  return error;
}

function getAccessToken(req, that, callbackURL, loggingContext) {
  const params = {
    'grant_type': 'authorization_code',
    'redirect_uri': callbackURL,
    code: req.query.code
  };
  const callback = passportUtils.getAccessTokenCallback(that, req);
  that._oauth2.getOAuthAccessToken(params, loggingContext, function (err, result) {
    if (err) {
      err.status = 500;
    }
    if (result) {
      result.urlTenant = req.tenant ? req.tenant : passportUtils.getUrlTenant(req);
    }
    let uaaOptions = req.extUaaConfigOptions ? req.extUaaConfigOptions : req.routerConfig.uaaConfig.options;
    if (result && pathUtil.pathAuthenticationType(req) === 'ias' && uaaOptions.url) {
      try {
        tokenUtils.exchangeToken(result.access_token, headerUtil.getCorrelationId(req), uaaOptions, function (err, xsuaaToken) {
          if (err) {
            err.status = 500;
            return callback(err);
          }
          result.xsuaaToken = jwtDecode(xsuaaToken);
          callback(err, result);
        });
      } catch (err) {
        return callback('Failed to get xsuaa credentials ' + err);
      }
    } else {
      callback(err, result);
    }
  });
}

/*
  * This function is used to check if state parameter is enabled for the requested application,
  * based on the locationAfterLogin cookie value.
  * It checks the stateProtection flag in xs-app.json of the application.
  * In case of failure, it returns true to avoid any security issues.
 */
async function isStateProtectionEnabledForCBurl(req, cookies, logger) {
  const genErrMessage = 'Failed to evaluate state parameter enabled';

  const locationAfterLogin  = cookies.locationAfterLogin;
  if (!locationAfterLogin) {
    logger.info(`${genErrMessage}: locationAfterLogin cookie is missing`);
    return true;
  }

  const getConfigurationsReq = _.cloneDeep(req);
  getConfigurationsReq.url = locationAfterLogin;

  // In order to calculate the getConfigurationsReq correct appKey, the dynamicRouting.appKey if the original request should be removed
  getConfigurationsReq.dynamicRouting && delete getConfigurationsReq.dynamicRouting.appKey;

  const appKey = drUtils.getApplicationKey(getConfigurationsReq);
  if (!appKey) {
    logger.info(`${genErrMessage}: Failed to extract application key from locationAfterLogin cookie. LocationAfterLogin: ${locationAfterLogin}`);
    return true;
  }

  let appConfig;
  try {
    appConfig = await drUtils.getConfigurations(getConfigurationsReq, appKey);
    if (appConfig && appConfig.xsapp && appConfig.xsapp.stateProtection === false) {
      return false;
    } else {
      return true;
    }
  } catch (e) {
    const entireAppKey = appKey ? appKey.entireKey : '';
    logger.info(`${genErrMessage}: Failed to fetch xs-app.json while evaluating state protection: ${e.message}. Application Key: ${entireAppKey}`);
    return true;
  }
}
