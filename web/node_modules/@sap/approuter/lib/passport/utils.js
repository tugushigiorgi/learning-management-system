'use strict';

const jwtDecode = require('jwt-decode');
const VError = require('verror').VError;
const headerUtil = require('../utils/header-util');
const urlUtils = require('../utils/url-utils');
const iasUtils = require('../utils/ias-utils');
const uaaUtils = require('../utils/uaa-utils');
const pathUtil = require('../utils/path-util');
const request = require('../utils/request-utils');
const urijs = require('urijs');
const configUtils = require('../utils/configuration-utils');
const logger = require('../utils/logger');
const vcapUtils = require('../utils/vcap-utils');
const cookieUtils = require('../utils/cookie-utils');

const tracer = logger.getTracer(__filename);

module.exports = {
  USER_NAME_NOT_APPLICABLE : 'n/a',
  MAX_ATTEMPTS_NUMBER: 3,
  storeToken: function (req, options, done) {
    req.session.regenerate(function (err) {
      if (err) {
        return done(err);
      }

      req.session.user = module.exports.getUserProperties(options);
      req.app.tenantInfo = {
        [req.session.user.tenant] : {
          tenantid : req.session.user.tenantid
        }
      };
      req.session.save();
      done(null, req.session.user);
    });
  },

  getUserProperties: function (options) {
    const token = jwtDecode(options.accessToken);
    const userName = token.user_name || token.email;
    const userId = token.user_uuid || userName;
    let scopes = [];
    const optionsScope = options.xsuaaToken && options.xsuaaToken.scope ? options.xsuaaToken.scope : options.scope;
    if (optionsScope) {
      scopes = optionsScope.trim ? optionsScope.trim().split(' ') : optionsScope;
    }
    return {
      id: userId,
      userId: userId || this.USER_NAME_NOT_APPLICABLE,
      name: userName || this.USER_NAME_NOT_APPLICABLE, // 'n/a' is for passport
      token: {
        accessToken: options.accessToken,
        jti: token.jti,
        idToken: options.idToken,
        authenticationType: options.oauthOptions ? options.oauthOptions.authenticationType : 'xsuaa',
        expiryDate: module.exports.getExpiresAt(options.expiresIn).getTime(),
        refreshToken: options.refreshToken,
        oauthOptions: options.oauthOptions,
        forwardCorpIdpToken: token.forward_corp_idp_token
      },
      tenantid: token.app_tid || token.zid || token.zone_uuid,
      scopes: scopes,
      tenant: (token.ext_attr && token.ext_attr.zdn) || options.urlTenant,
      urlTenant: options.urlTenant,
      xsuaaToken: options.xsuaaToken,
      sid: token.sid
    };
  },

  getExpiresAt: function (duration) {
    // respect network latency if possible
    let expiresIn;
    if (duration > 180) {
      expiresIn = duration - 120;
    } else {
      expiresIn = duration;
    }
    return new Date(new Date().getTime() + expiresIn * 1000);
  },

  getCallBackUrl: function (req) {
    const appRouterUrl = urlUtils.buildAppRouterUrl(req);
    const loginCallback = multipleAuthTypes(req) ? req.routerConfig.appConfig.login.callbackEndpoint + '?authType=' + pathUtil.pathAuthenticationType(req) :
      req.routerConfig.appConfig.login.callbackEndpoint;
    let proxyPrefix = '';

    if (req.headers['x-forwarded-path']) {
      let toCutOut = req.url.length;
      const parsedUrl = urijs.parse(req.url);
      if (req.headers['x-forwarded-path'].indexOf(loginCallback) > -1 && parsedUrl.query) {
        toCutOut = loginCallback.length;
      }
      const parsedXForwardedPath = urijs.parse(req.headers['x-forwarded-path']);
      proxyPrefix = parsedXForwardedPath.path.substr(0, parsedXForwardedPath.path.length - toCutOut +
        (req.url[0] === '/' ? 1 : 0));
    }
    return urlUtils.join(appRouterUrl + proxyPrefix, loginCallback);
  },

  loadOauthOptions: function (req, cb) {
    const authenticationType = pathUtil.pathAuthenticationType(req);
    module.exports.getAuthConfig(req, authenticationType, function (err, authOptions) {
      if (err) {
        return cb(err);
      }
      const url = authOptions.url;
      const apptid = req.zoneInfo && req.zoneInfo.apptid;
      // If route authenticationType is defined and differs from tenantLoginInfo API (zoneInfo) authenticationType,
      // prefer route authenticationType and ignore zoneInfo using existing determination logic.
      const zoneInfo = req.zoneInfo && (req.zoneInfo.authenticationType === authenticationType) && req.zoneInfo;
      const options = {
        authorizationURL: zoneInfo ? zoneInfo.authorizationEndpoint : urlUtils.join(url, authenticationType === 'ias' ? '/oauth2/authorize' : '/oauth/authorize'),
        tokenURL: zoneInfo ? zoneInfo.tokenEndpoint : urlUtils.join(authOptions.certurl || url, authenticationType === 'ias' ? '/oauth2/token' : '/oauth/token'),
        clientid: authOptions.clientid,
        clientsecret: authOptions.clientsecret,
        certificate: authOptions.certificate,
        key: authOptions.key,
        url:  url,
        callbackURL: module.exports.getCallBackUrl(req),
        customHeaders: {'x-correlationid': headerUtil.getCorrelationId(req)},
        scope: authenticationType === 'ias' ? 'openid' : null,
        authenticationType: authenticationType,
        apptid: authenticationType === 'ias' ? apptid : undefined
      };
      const logoutProvider = require('../middleware/logout-provider');
      const backChannelLogoutEndpoint = logoutProvider.getBackChannelLogoutEndpoint(req);
      const loginCallbackEndpoint = req.routerConfig && req.routerConfig.appConfig && req.routerConfig.appConfig.login
            && req.routerConfig.appConfig.login.callbackEndpoint;
      const isLoginCallback = req.url.includes(loginCallbackEndpoint);
      if (backChannelLogoutEndpoint && isLoginCallback) {
        if (req.headers.cookie) {
          const cookies = req.headers.cookie.split(';').map(c => c.trim());
          const jSessionIdCookie = cookies.find(c => c.startsWith(`${cookieUtils.getSessionCookieName()}=`));
          const platformCookie = cookies.find(c => c.startsWith(`${cookieUtils.getPlatformCookieName()}=`));
          if (!jSessionIdCookie && !platformCookie) {
            return cb(new VError('Missing required session or platform cookie for backchannel logout'));
          }

          const backChannelLogoutUri = getBackChannelLogoutUri(req, backChannelLogoutEndpoint);
          const cookieHeaderValue = [platformCookie, jSessionIdCookie].filter(Boolean).join(';');

          options.tokenURL += `?s3bcl_header_name=cookie&s3bcl_header_value=${cookieHeaderValue}`;
          options.tokenURL += `&s3bcl_logout_uri=${backChannelLogoutUri}`;
        }
      }
      headerUtil.updateSapPassport(req.headers, options.customHeaders);
      cb(null, options);
    });
  },

  getAccessTokenCallback: function (strategy, req) {
    return function accessTokenCallback(err, result) {
      if (err) {
        const error = new VError(err, 'Could not obtain access token');
        error.status = err.status;
        return strategy.error(error);
      }

      function verified(err, user, info) {
        if (err) {
          return strategy.error(err);
        }
        if (!user) {
          return strategy.fail(info);
        }
        strategy.success(user, info);
      }

      try {
        strategy.verify(req, result, verified);
      } catch (ex) {
        return strategy.error(ex);
      }
    };
  },

  callUaa: function (requestOptions, shouldDoRequest, cb) {
    const requestStart = Date.now();
    let attemptsNum = module.exports.MAX_ATTEMPTS_NUMBER;
    let responseJSON;

    function doRequest() {
      if (shouldDoRequest) {
        let error = shouldDoRequest();
        if (error) {
          return cb(error);
        }

      }
      request.post(requestOptions, function onResponse(err, res, body) {
        if (err || res.statusCode !== 200) {
          tracer.info(err, 'Request attempt %d to authentication service at %s failed in %d ms.', module.exports.MAX_ATTEMPTS_NUMBER - attemptsNum + 1, requestOptions.url, Date.now() - requestStart);
          --attemptsNum;
          if (!attemptsNum) {
            if (res && res.statusCode !== 200) {
              let data;
              try {
                data = res && res.response && res.response.data && JSON.parse(res.response.data);
              } catch (parseErr){
                tracer.info(parseErr, 'Failed to parse response data');
              }

              const reason = data ? `${data.error}, error description: ${data.error_description}` : (res.message || 'no reason provided');
              const error = new VError('unexpected response from authentication service at %s: status code: %d, reason: %s',
                requestOptions.url, res.statusCode, reason);
              error.status = res.statusCode;
              return cb(error);
            }
            return cb(new VError(err, 'Request to authentication service failed'));
          }
          return doRequest();
        }
        try {
          responseJSON = JSON.parse(body);
        } catch (err) {
          return cb(new VError(err, 'unexpected response from authentication service. Expected json, got: "%s"', body));
        }
        cb(null, responseJSON);
      });
    }

    doRequest();
  },

  getAuthConfig: function (req, authenticationType, cb) {
    if (authenticationType === 'ias') {
      return iasUtils.getIasConfig(req, cb);
    } else {
      return uaaUtils.getUaaConfig(req, cb);
    }
  },

  getAuthCertificates: function (session, destination, opts) {
    const oauthOptions = session && session.user && session.user.token && session.user.token.oauthOptions;
    if (destination && destination.forwardAuthCertificates) {
      if (oauthOptions && oauthOptions.certificate && oauthOptions.key) {
        opts.cert = oauthOptions.certificate;
        opts.key = oauthOptions.key;
        tracer.info('Adding auth service client certificate to backend request ' + destination.url);
      } else {
        tracer.error(`Destination ${destination.name} is configured to forward authentication certificates but no certificates exists in auth. service binding`);
      }
    }
  },

  getUrlTenant: function (req) {
    let tenant = null;
    if (process.env.TENANT_HOST_PATTERN) {
      let requestHost = urlUtils.getAppRouterHost(req);
      let tenantHostPattern = configUtils.constructRegExp(process.env.TENANT_HOST_PATTERN);
      tenant = uaaUtils.retrieveTenantFromURL(requestHost, tenantHostPattern);
    }
    return tenant;
  },

  getTenantInfo: function (req) {
    const routerConfig = req.app && req.app.get && req.app.get('mainRouterConfig');
    const uuaOptions = routerConfig && routerConfig.uaaConfig  && routerConfig.uaaConfig.options;
    const iasOptions = routerConfig && routerConfig.iasConfig  && routerConfig.iasConfig.options;
    const sourceTenant = ((uuaOptions && uuaOptions.identityzone) || (iasOptions && iasOptions.identityzone));
    const isMultiTenant = !! process.env.TENANT_HOST_PATTERN;
    const tenant = isMultiTenant ? module.exports.getUrlTenant(req) : sourceTenant;
    const tenantid = req.app && req.app.tenantInfo && req.app.tenantInfo[tenant] && req.app.tenantInfo[tenant].tenantid;
    return {
      multitenant : isMultiTenant,
      tenantid : tenantid || (!isMultiTenant && (uuaOptions && uuaOptions.tenantid) || (iasOptions && iasOptions.tenantid)),
      tenant: tenant,
      sourceTenant: sourceTenant,
      logInfo: (sourceTenant && tenant) && (sourceTenant !== tenant) ? `${sourceTenant}!${tenant}` : tenant && `${tenant}`
    };
  }
};

function multipleAuthTypes(req) {
  return req && req.routerConfig && req.routerConfig.iasConfig && req.routerConfig.iasConfig.options &&
    req.routerConfig.iasConfig.options.url && req.routerConfig.uaaConfig && req.routerConfig.uaaConfig.options &&
    req.routerConfig.uaaConfig.options.url;
}

function getBackChannelLogoutUri(req, backChannelLogoutEndpoint) {
  let backChannelLogoutUri = req && req.routerConfig && req.routerConfig.backChannelLogoutUri;
  if (!backChannelLogoutUri && req) {
    const urlTenant = module.exports.getUrlTenant(req);
    const smsCredentials = vcapUtils.getServiceCredentials({ label: 'subscription-manager' });
    const providerTenant = smsCredentials && smsCredentials.identityzone;
    const proto = 'https://';
    const backChannelLogoutHost =  (urlTenant && providerTenant) ? `${proto}${urlUtils.getRedirectHost(req).replace(urlTenant, providerTenant)}`
      : `${proto}${urlUtils.getRedirectHost(req)}`;
    backChannelLogoutUri = `${backChannelLogoutHost}${backChannelLogoutEndpoint}`;
  }
  return backChannelLogoutUri;
}
