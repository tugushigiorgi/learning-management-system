export = Token;
/**
 * @typedef {import('../util/Types').JwtHeader} JwtHeader
 * @typedef {import('../util/Types').JwtPayload} JwtPayload
 */
declare class Token {
    /**
     * @param {string} jwt
     * @param {object} [content] - optional parsed header and payload
     * @param {string} [content.header] - parsed header
     * @param {string} [content.payload] - parsed payload
     */
    constructor(jwt: string, { header, payload }?: {
        header?: string;
        payload?: string;
    });
    get audiences(): string[];
    get azp(): any;
    get clientId(): any;
    get email(): any;
    /**
     * Returns whether the token is expired based on claim exp (expiration time).
     * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
     * @return {Boolean} false if token has a positive {@link remainingTime}, true otherwise
     */
    get expired(): boolean;
    get expirationDate(): Date;
    get familyName(): any;
    get givenName(): any;
    get grantType(): any;
    /** @return {JwtHeader} Token header as parsed object */
    get header(): JwtHeader;
    get issuer(): string;
    get issueDate(): Date;
    /** @return {String} JWT used to construct this Token instance as raw String */
    get jwt(): string;
    /**
     * Returns whether the token is not yet valid based on the optional nbf (no use before) claim.
     * There is a 1min leeway before the nbf in which the token already counts as valid to account for clock skew.
     * @return {Boolean} true if token has nbf and nbf date lies in future, false otherwise
     */
    get notYetValid(): boolean;
    get origin(): any;
    /** @return {JwtPayload} Token payload as parsed object */
    get payload(): JwtPayload;
    /**
     * Returns the remaining time until expiration in seconds based on claim exp (expiration time).
     * There is a 1min leeway after the exp in which the token still counts as valid to account for clock skew.
     * @returns seconds until expiration or 0 if expired
     */
    get remainingTime(): number;
    get subject(): string;
    get userName(): any;
    get userId(): any;
    getAudiencesArray(): string[];
    getAzp(): any;
    getClientId: () => any;
    getEmail(): any;
    getExpirationDate(): Date;
    getFamilyName(): any;
    getGivenName(): any;
    getGrantType(): any;
    getHeader(): import("../util/Types").JwtHeader;
    getIssuedAt(): Date;
    getIssuer(): string;
    getPayload(): import("../util/Types").JwtPayload;
    getSubject(): string;
    getTokenValue(): string;
    getUserId(): any;
    #private;
}
declare namespace Token {
    export { JwtHeader, JwtPayload };
}
type JwtHeader = import("../util/Types").JwtHeader;
type JwtPayload = import("../util/Types").JwtPayload;
//# sourceMappingURL=Token.d.ts.map