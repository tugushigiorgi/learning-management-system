export = createSecurityContext;
/**
 * @typedef {import("../service/Service")} Service
 * @typedef {import("../util/Types").SecurityContextConfig} SecurityContextConfig
 */
/**
 * Tries to create a new security context by authenticating the user via the given service(s) based on a jwt token.
 * If the jwt is missing or cannot be validated, an error will be thrown.
 * The contextConfig must either contain a jwt token directly or a req object from whose Authorization header the jwt can be extracted as Bearer token.
 * @template {Service} T - The type of the service from which the security context is created
 * @param {T|T[]} services - The service or array of services to authenticate the user
 * @param {SecurityContextConfig} contextConfig - The configuration object containing the jwt token or req object
 * @returns {ReturnType<T['createSecurityContext']>} - A promise that resolves to the security context created by the target service
 * @throws {import('../error/XssecError')} - Error with a descriptive message and a suggested statusCode for the application response. The cause of the error can be checked via instanceof against the various XssecError subclasses.
 */
declare function createSecurityContext<T extends Service>(services: T | T[], contextConfig: SecurityContextConfig): ReturnType<T["createSecurityContext"]>;
declare namespace createSecurityContext {
    export { Service, SecurityContextConfig };
}
type Service = import("../service/Service");
type SecurityContextConfig = import("../util/Types").SecurityContextConfig;
//# sourceMappingURL=createSecurityContext.d.ts.map