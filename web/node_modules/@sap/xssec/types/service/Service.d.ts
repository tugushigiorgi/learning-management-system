export = Service;
/**
 * @typedef {import('../token/Token')} Token
 * @typedef {import('../context/SecurityContext')} SecurityContext
 * @typedef {import('../jwks/Jwks')} Jwks
 * @typedef {import('../error/validation/ValidationError')} ValidationError
 * @typedef {import('../util/Types').ServiceCredentials} ServiceCredentials
 * @typedef {import('../util/Types').ServiceConfig} ServiceConfig
 * @typedef {import('../util/Types').SecurityContextConfig} SecurityContextConfig
 * @typedef {import('../util/Types').TokenFetchOptions} TokenFetchOptions
 * @typedef {import('../util/Types').TokenFetchResponse} TokenFetchResponse
 * @typedef {import('../util/Types').GrantType} GrantType
 */
declare class Service {
    static "__#5@#sharedJwksCaches": {};
    static "__#5@#oidcCache": any;
    /**
     * Builds the configuration of this service based on the provided configuration and default values.
     * @param {ServiceConfig} serviceConfiguration
     */
    static buildServiceConfiguration(config: any): any;
    /**
     *
     * @param {ServiceCredentials} credentials
     * @param {ServiceConfig} [serviceConfiguration={}]
     */
    constructor(credentials: ServiceCredentials, serviceConfiguration?: ServiceConfig);
    /** @type {ServiceCredentials} */
    credentials: ServiceCredentials;
    /** @type {ServiceConfig} */
    config: ServiceConfig;
    endpoints: {
        oidc_info: string;
    };
    jwksCache: any;
    /**
     * @internal
     * Sets the OIDC cache shared by all Service instances.
     */
    set oidcCache(cache: import("../cache/ResponseCache"));
    /**
     * @internal
     * Gets the OIDC cache shared by all Service instances.
     *
     * @returns {import("../cache/ResponseCache")} The OIDC cache.
     */
    get oidcCache(): import("../cache/ResponseCache");
    /**
     * Checks if this service is the recipient of the given token.
     * @param {Token} token
     * @returns {Boolean}
     */
    acceptsTokenAudience(token: Token): boolean;
    /**
     * Called internally to validate the credentials to have the necessary properties before performing a specific action, e.g. token fetch.
     *
     * @internal
     * @param {string} action description of action for which the credentials are being validated.
     * @param {...string} mandatoryProperties mandatory properties that must be present in the credentials.
     * @throws {InvalidCredentialsError} if any of the mandatory properties are missing in the credentials.
     */
    validateCredentials(action: string, ...mandatoryProperties: string[]): void;
    /**
     * Checks if the given token is valid under the given contextConfig.
     * @param {Token} token
     * @param {SecurityContextConfig} contextConfig
     * @throws {ValidationError} if the token is not valid or could not be validated
    */
    validateToken(token: Token, contextConfig: SecurityContextConfig): Promise<void>;
    /**
     * Checks if the given token's signature is valid under the given contextConfig.
     * @param {Token} token
     * @param {SecurityContextConfig} contextConfig
     * @returns {Promise<void>} resolves when token signature is valid, otherwise error is thrown
     * @throws {ValidationError} if the token signature is not valid or could not be validated
     */
    validateTokenSignature(token: Token, contextConfig: SecurityContextConfig): Promise<void>;
    /**
     * @param {object} [requestOptions]
     * @param {string} [requestOptions.correlationId]
     */
    getOpenIDConfiguration({ correlationId }?: {
        correlationId?: string;
    }): Promise<any>;
    /**
     * @param {object} [requestOptions]
     * @param {string} [requestOptions.correlationId]
     */
    fetchOpenIDConfiguration({ correlationId }?: {
        correlationId?: string;
    }): Promise<any>;
    /**
     * Fetches a token from this service with this service's client credentials.
     * @param {TokenFetchOptions} options
     * @returns {Promise<TokenFetchResponse>} response
     */
    fetchClientCredentialsToken(options?: TokenFetchOptions): Promise<TokenFetchResponse>;
    /**
     * Fetches a user token from this service with the given username and password.
     * @param {String} username
     * @param {String} password
     * @param {TokenFetchOptions} options
     * @returns {Promise<TokenFetchResponse>} response
     */
    fetchPasswordToken(username: string, password: string, options?: TokenFetchOptions): Promise<TokenFetchResponse>;
    /**
     * Fetches a JWT bearer token from this service with the given user token as assertion.
     * @param {TokenFetchOptions} options - default timeout is 10 seconds as JWT bearer can be slow
     * @returns {Promise<TokenFetchResponse>} response
     */
    fetchJwtBearerToken(assertion: any, options?: TokenFetchOptions): Promise<TokenFetchResponse>;
    /**
     * @param {String} grant_type
     * @param {TokenFetchOptions} options
     */
    buildTokenRequest(grant_type: string, options: TokenFetchOptions): {
        method: string;
        body: URLSearchParams;
    };
    /**
     * Prepares the given request to use this service's client credentials for authentication.
     * Adds clientid and either clientsecret or an mTLS agent based on client certificate, depending on the type of credentials.
     * @param {RequestInit} request
     * @param {URLSearchParams} request.body
     * @param {TokenFetchOptions} options
     */
    addClientAuthentication(request: RequestInit, options?: TokenFetchOptions): void;
    /**
     * Updates the certificate and key in the service credentials for authentication of subsequent requests.
     * @param {String} cert PEM-encoded client certificate
     * @param {String} key PEM-encoded client key
     * @returns {void}
     */
    setCertificateAndKey(cert: string, key: string): void;
    /**
     * Creates a new {@link SecurityContext} from this service with the given token.
     * @abstract
     * @param {String|Token} token as JWT or Token object
     * @param {SecurityContextConfig} contextConfig
     * @returns {Promise<SecurityContext>} securityContext
     */
    createSecurityContext(token: string | Token, contextConfig?: SecurityContextConfig): Promise<SecurityContext>;
    /**
     * Retrieves the JWKS (JSON Web Key Set) for the given token and context configuration.
     *
     * @param {string} token the token for which to retrieve the JWKS.
     * @param {SecurityContextConfig} contextConfig the context configuration object.
     * @returns {Promise<Jwks>} A promise that resolves to the JWKS (JSON Web Key Set) object.
     * @throws {Error} If an error occurs while retrieving the JWKS.
     */
    getJwks(token: string, contextConfig: SecurityContextConfig): Promise<Jwks>;
    /**
     * Determines the URL that can be used for fetching tokens of given grant_type from this service.
     * @abstract
     * @param {GrantType} grant_type
     * @param {Object} options
     * @param {String} options.correlationId
     * @returns {Promise<URL>} URL of the service's token endpoint
     */
    getTokenUrl(grant_type: GrantType, options?: {
        correlationId: string;
    }): Promise<URL>;
    #private;
}
declare namespace Service {
    export { Token, SecurityContext, Jwks, ValidationError, ServiceCredentials, ServiceConfig, SecurityContextConfig, TokenFetchOptions, TokenFetchResponse, GrantType };
}
type Token = import("../token/Token");
type SecurityContext = import("../context/SecurityContext")<any, any>;
type Jwks = import("../jwks/Jwks");
type ValidationError = import("../error/validation/ValidationError");
type ServiceCredentials = import("../util/Types").ServiceCredentials;
type ServiceConfig = import("../util/Types").ServiceConfig;
type SecurityContextConfig = import("../util/Types").SecurityContextConfig;
type TokenFetchOptions = import("../util/Types").TokenFetchOptions;
type TokenFetchResponse = import("../util/Types").TokenFetchResponse;
type GrantType = import("../util/Types").GrantType;
//# sourceMappingURL=Service.d.ts.map